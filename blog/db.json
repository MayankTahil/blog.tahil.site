{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hiker/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/home.css","path":"css/home.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/dialog.css","path":"css/dialog.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/archive.css","path":"css/archive.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/header-post.css","path":"css/header-post.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/vdonate.css","path":"css/vdonate.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/dialog.js","path":"js/dialog.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/home.js","path":"js/home.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/scripts.js","path":"js/scripts.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/vdonate.js","path":"js/vdonate.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/meta.js","path":"js/meta.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/js/jquery-3.1.1.min.js","path":"js/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/mylogo-icon.png","path":"css/images/mylogo-icon.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/mylogo.png","path":"css/images/mylogo.png","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/about-3.jpg","path":"css/images/about-3.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/home-bg-1.jpg","path":"css/images/home-bg-1.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/about-2.jpg","path":"css/images/about-2.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/about-1.jpg","path":"css/images/about-1.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/home-bg-2.jpg","path":"css/images/home-bg-2.jpg","modified":0,"renderable":1},{"_id":"themes/hiker/source/css/images/home-bg-3.jpg","path":"css/images/home-bg-3.jpg","modified":0,"renderable":1},{"_id":"source/about/index/resume.png","path":"about/index/resume.png","modified":1,"renderable":0},{"_id":"source/about/index/github.png","path":"about/index/github.png","modified":1,"renderable":0},{"_id":"source/about/index/linkedin.png","path":"about/index/linkedin.png","modified":1,"renderable":0},{"_id":"source/about/index/twitter.png","path":"about/index/twitter.png","modified":1,"renderable":0},{"_id":"source/about/index/instagram.png","path":"about/index/instagram.png","modified":1,"renderable":0},{"_id":"source/about/index/email.png","path":"about/index/email.png","modified":1,"renderable":0},{"_id":"source/about/index/rss.png","path":"about/index/rss.png","modified":1,"renderable":0},{"_id":"source/about/index/docker.png","path":"about/index/docker.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"b1a364497b3ab0088aa224b767800ea67517393a","modified":1513368780000},{"_id":"themes/hiker/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1513119498000},{"_id":"themes/hiker/.DS_Store","hash":"32165322ee6dba2dc085002d8ecf483d2f54e985","modified":1513238065000},{"_id":"themes/hiker/README.cn.md","hash":"f3e0654da249429968cf15a04cef7bd19cf1ec53","modified":1513233616000},{"_id":"themes/hiker/README.md","hash":"57eccf6c0d3a3467ae09ceb89d7a2eb782181971","modified":1513119498000},{"_id":"themes/hiker/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1513119498000},{"_id":"themes/hiker/.travis.yml","hash":"24851843a40973daaee47b2697e8b0dc4e6556b3","modified":1513119498000},{"_id":"themes/hiker/package.json","hash":"ac7430d36de467f41a686fb716c8538c52f0e206","modified":1513119498000},{"_id":"themes/hiker/LICENSE","hash":"4ea4173f28adf2f688a59e3c5e6fa833bcdf7ced","modified":1513119498000},{"_id":"themes/hiker/_config.yml","hash":"6ef1dffaeca51139cda73ff88d5b18e5d11cc0f7","modified":1513366225000},{"_id":"source/_posts/.DS_Store","hash":"00ecd29303af0420deed49d0c74a9445660b0cbc","modified":1513304364000},{"_id":"source/_posts/docker-101-mod1.md","hash":"87e1bf7627122cffd79808071e608d2af91edcbb","modified":1513366386000},{"_id":"source/_posts/docker-101.md","hash":"c200f8e993f2e8b4430f95a5cadca627430ef71a","modified":1513326569000},{"_id":"source/_posts/docker-101-mod2.md","hash":"b07a22ad221838621344458630d2880299375897","modified":1513323735000},{"_id":"source/_posts/docker-101-mod3.md","hash":"ce5dd1e0ae2e898487b8438a7a3828eeafdef181","modified":1513323737000},{"_id":"source/about/index.md","hash":"3fa559ec2ec5d091b09081765f5adf0635c268f4","modified":1513375008000},{"_id":"source/_template/docker-101-TOC.md","hash":"acf9924b123234e2888f294b881e07eebe700bfe","modified":1513323107000},{"_id":"source/_code/docker-101/Dockerfile","hash":"b284b8109bdbb9479fda81d576f67a9a71307cb4","modified":1513223463000},{"_id":"source/_code/docker-101/docker-compose.yml","hash":"32a25cbbc9a5c8f0e4150b47fda930a087eab9de","modified":1513223464000},{"_id":"themes/hiker/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1513119498000},{"_id":"themes/hiker/scripts/excerpt.js","hash":"aa53aaf29dc831b8be5445e48cd19399f88825b9","modified":1513325688000},{"_id":"source/_posts/docker-101/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1513295071000},{"_id":"themes/hiker/languages/de.yml","hash":"3e244f9c48b641edd821bdeb743bdbcd0919685f","modified":1513119498000},{"_id":"themes/hiker/languages/default.yml","hash":"20972f2b7da96a043e6e836ac8c91c97c60711b2","modified":1513241403000},{"_id":"themes/hiker/languages/en.yml","hash":"20972f2b7da96a043e6e836ac8c91c97c60711b2","modified":1513241390000},{"_id":"themes/hiker/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1513119498000},{"_id":"themes/hiker/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1513119498000},{"_id":"themes/hiker/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1513119498000},{"_id":"themes/hiker/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1513119498000},{"_id":"themes/hiker/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1513119498000},{"_id":"themes/hiker/languages/zh-CN.yml","hash":"2f0bcf559dd78025679872511adfcf40e85e9ff5","modified":1513119498000},{"_id":"themes/hiker/source/.DS_Store","hash":"fb5c56980e039caee1020a2cbc343e6a5bac3933","modified":1513244035000},{"_id":"themes/hiker/languages/pt.yml","hash":"46bd5f121f4704e2cd6c0950ec18b549f03bfe5c","modified":1513119498000},{"_id":"themes/hiker/languages/zh-TW.yml","hash":"7672fbe7ee9c166f77bc644647295f5886cbc50e","modified":1513119498000},{"_id":"source/_posts/docker-101-mod1/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1513295044000},{"_id":"source/_posts/docker-101-mod3/topology.jpg","hash":"2362695bebe8fb44752b00717b00cb8e03c7348a","modified":1513223464000},{"_id":"themes/hiker/layout/.DS_Store","hash":"f67e8580843bf308c05d25a059507bc25df72a62","modified":1513227749000},{"_id":"themes/hiker/layout/archive.ejs","hash":"456ccaa190a3a09c72a5413cf0b4f9eed6464569","modified":1513241024000},{"_id":"themes/hiker/layout/categories.ejs","hash":"9987d81034cc4c571fc3b3a07f6a4b21e93a762c","modified":1513232960000},{"_id":"themes/hiker/layout/category.ejs","hash":"864534f116c1383b800b648a630f36728cee2bcf","modified":1513232938000},{"_id":"themes/hiker/layout/layout.ejs","hash":"aa685e9762a356f9b677e6f9d17e04694492fb83","modified":1513315489000},{"_id":"themes/hiker/layout/page.ejs","hash":"aaedd3d06a752b6d96fd1901b2dfec2588b35b28","modified":1513315564000},{"_id":"themes/hiker/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1513316754000},{"_id":"themes/hiker/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1513329377000},{"_id":"themes/hiker/layout/tags.ejs","hash":"022aaf95431bda03f59063287a26d4def6d672d7","modified":1513225741000},{"_id":"themes/hiker/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1513119498000},{"_id":"source/_posts/docker-101/containers-visual.png","hash":"170fad9efe94705686a0bfb1971f3e36cb66d2cd","modified":1513223464000},{"_id":"source/_posts/docker-101/docker-images.png","hash":"570046955ba68e531d5f78b0392a482664d42dd5","modified":1513223463000},{"_id":"themes/hiker/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513119498000},{"_id":"themes/hiker/source/css/_extend.styl","hash":"5a2b18b03c18c92f130771aa97737e100202d21b","modified":1513119498000},{"_id":"themes/hiker/source/css/_variables.styl","hash":"5c4bb7b274a9b89929a93f8171ad4fc7079e70f6","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1513119498000},{"_id":"themes/hiker/source/css/.DS_Store","hash":"9933301a08e6c4c5ce81fb62cbdef72dc50f25b2","modified":1513227838000},{"_id":"themes/hiker/source/css/home.css","hash":"79d3a30fea323c240b4cbe38e260c1d9609dbb67","modified":1513305849000},{"_id":"themes/hiker/source/css/dialog.css","hash":"5e0333adf3f496e0d443767fe228a1d4b1a2bafc","modified":1513119498000},{"_id":"themes/hiker/source/css/archive.css","hash":"17cc72203cad1b0be66008d662c7494507aaee8b","modified":1513119498000},{"_id":"themes/hiker/source/css/header-post.css","hash":"3f6d1f5593a353b4b05a67ee14e04ec9c986db21","modified":1513119498000},{"_id":"themes/hiker/source/css/vdonate.css","hash":"bca2d291a71e7358654c51f23e8bfb467b2bc8b2","modified":1513119498000},{"_id":"themes/hiker/source/css/style.styl","hash":"cbf244726bf1fde4d278b4d3768e289f9f64ae35","modified":1513119498000},{"_id":"themes/hiker/source/js/insight.js","hash":"f79ab175d1c8c4fb59328ee4fd9eb95808eb0be5","modified":1513119498000},{"_id":"themes/hiker/source/js/dialog.js","hash":"01e8b337c1721e0486fd5044f98b233e84ba1985","modified":1513119498000},{"_id":"themes/hiker/source/js/home.js","hash":"e403c3290d76c5f58571cbfe4414236e41a7ac94","modified":1513119498000},{"_id":"source/_posts/docker-101-mod2/cpx-blog-2-footer.png","hash":"dddd741a161ae1d448f30b370158616e942fa1bc","modified":1513223463000},{"_id":"source/_posts/docker-101-mod2/cpx-blog-1-footer.png","hash":"d61d8f482b20e5a455827c211b053ba26d5811e8","modified":1513223463000},{"_id":"themes/hiker/source/js/scripts.js","hash":"e06a8948375df71cbf77abf8617db438ece811b3","modified":1513119498000},{"_id":"themes/hiker/source/js/totop.js","hash":"29bb40144ac238d22b25d59df465aff8dc38bfd0","modified":1513119498000},{"_id":"themes/hiker/source/js/vdonate.js","hash":"5738414c642d30e43943a69287b3d25a0b6be135","modified":1513119498000},{"_id":"themes/hiker/layout/_widget/archive.ejs","hash":"9fffde4e794b35f07c96eaec6d9373a40014da8f","modified":1513119498000},{"_id":"themes/hiker/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1513119498000},{"_id":"themes/hiker/source/js/meta.js","hash":"9a8b3c4dd49d94aedd82a6b8f7bf114d9fcfaa08","modified":1513229989000},{"_id":"themes/hiker/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1513119498000},{"_id":"themes/hiker/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1513119498000},{"_id":"themes/hiker/layout/_widget/social.ejs","hash":"450bb1fe4bf1d416811f0104a50e69eb7ddde4bb","modified":1513272223000},{"_id":"themes/hiker/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/archive-post.ejs","hash":"55d661b63ffe41489bffe4d0570af50a1b952d63","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/after-footer.ejs","hash":"cf844d9dda22b63e990c2b9e5c8bee82c41fd3aa","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/archive.ejs","hash":"5fd48f4e5eaeec619d0c1ba5e7e97a20767d11f7","modified":1513275249000},{"_id":"themes/hiker/layout/_partial/article.ejs","hash":"6dd7b23dcffc2a3b0b29f738123059dc5b19ee9f","modified":1513362617000},{"_id":"themes/hiker/layout/_partial/busuanzi-analytics.ejs","hash":"7de568681c315e88127bec120b8100ce6640210f","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/baidu-analytics.ejs","hash":"5776714a003d2b96b04b5399f67e0899d821247e","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/cnzz-analytics.ejs","hash":"87410fedf15383f119706c96f71552be14248d57","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/donate.ejs","hash":"14aeccd42fd3551fd51e2f23f29114d2a9f425ee","modified":1513234525000},{"_id":"themes/hiker/layout/_partial/comment.ejs","hash":"1471bafc3e1b348cdd081ad8f79e6656323ec04b","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/dialog.ejs","hash":"4ac694cdfc2672a44c67b2618c6a70b6410af198","modified":1513199318000},{"_id":"themes/hiker/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/footer.ejs","hash":"670da18b56d2df4452a4433a82603038f3eed3db","modified":1513365940000},{"_id":"themes/hiker/layout/_partial/facebook-sdk.ejs","hash":"06038db50d2e1febdefa3f8e1512b332c7da5a17","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/head.ejs","hash":"7c84f7a020b0fc177c653e52193f6a49b5f47475","modified":1513238744000},{"_id":"themes/hiker/layout/_partial/header.ejs","hash":"ae2f6aa4519715dacaf863d471dffd891013847f","modified":1513249937000},{"_id":"themes/hiker/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/tencent-analytics.ejs","hash":"93120ad06c5d73ca777470faf570e993a805e049","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/header-post.ejs","hash":"9fad28e1592f7f28548cb9736c0c785386d5e372","modified":1513363317000},{"_id":"themes/hiker/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1513274818000},{"_id":"themes/hiker/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1513327777000},{"_id":"themes/hiker/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1513119498000},{"_id":"themes/hiker/layout/search/insight.ejs","hash":"c97ef6478f8cd45458614cd78511c23cbd4e7a28","modified":1513119498000},{"_id":"themes/hiker/layout/search/index.ejs","hash":"a027a663baaffa212f5eb4947d43008419376177","modified":1513119498000},{"_id":"themes/hiker/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1513119498000},{"_id":"themes/hiker/source/css/bootstrap.css","hash":"64fdc2e7c3f8a164d21c5632b5adbbb9990ea802","modified":1513366633000},{"_id":"themes/hiker/source/js/bootstrap.js","hash":"3b965a36a6b08854ad6eddedf85c5319fd392b4a","modified":1513119498000},{"_id":"themes/hiker/source/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/footer.styl","hash":"ce9f600140d5cd246b59374f615c8a512bc5ecab","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/archive.styl","hash":"28e78ec6e703417c50447c4710ad4bcf6cf48008","modified":1513240706000},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1513119498000},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/comment.styl","hash":"f23dbf9c1224559314f7d10b7fee030a9ffab58a","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/header.styl","hash":"4bbc6be125b55de743ad00a5ddf751eba1f617c4","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/article.styl","hash":"eb8ebae6f45a08c6b71eb8f9aeff70a277cab388","modified":1513305754000},{"_id":"themes/hiker/source/css/_partial/header-post.styl","hash":"7ffaafa1d5d756b0271c82117b21188b339c4baa","modified":1513363188000},{"_id":"themes/hiker/source/css/_partial/sidebar-aside.styl","hash":"2d1117aa4306fb5df8bdd08c326de9bb5488e064","modified":1513241162000},{"_id":"themes/hiker/source/css/_partial/insight.styl","hash":"8cd23d8f0ce2d083dd7409a1a95315029070cbb8","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/mobile.styl","hash":"fcfbaf24634519063af46953e0eb733a8ada5556","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/highlight.styl","hash":"ae20f587f9905a684f60bee9e74570a413d4a6cb","modified":1513119498000},{"_id":"themes/hiker/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/sidebar-bottom.styl","hash":"36886d5436bfafbf980539be8dbc419631b8b6ee","modified":1513119498000},{"_id":"themes/hiker/source/css/_partial/sidebar.styl","hash":"e93ca6bb5b709accd667b939980ad39582fe062b","modified":1513119498000},{"_id":"themes/hiker/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1513119498000},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1513119498000},{"_id":"themes/hiker/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1513119498000},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1513119498000},{"_id":"themes/hiker/source/css/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1513227838000},{"_id":"themes/hiker/source/css/images/mylogo-icon.png","hash":"181ab0c44a29849366a1df15799eda8411e0f79f","modified":1513237973000},{"_id":"themes/hiker/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1513119498000},{"_id":"themes/hiker/source/css/images/mylogo.png","hash":"99b8c8e1683e742a4f4d3debfd48cacd26c55e5b","modified":1513249701000},{"_id":"themes/hiker/layout/_partial/post/busuanzi-analytics.ejs","hash":"4ef5022062c8ee59f3413bc92e6b3ae0d5020738","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/date.ejs","hash":"380985bb414f9a0d517834f65cce57bc0b493d8c","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/category.ejs","hash":"877a164bb13b46756eb111ec7bfe338a1eb36ad1","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/gallery.ejs","hash":"30028f10a4f03561e53da323d06b292e1ae7990c","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/title.ejs","hash":"a61267f27f2148321e549344be91dbc4e22e1a48","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/mathjax.ejs","hash":"571c19f57c2b38ac5cd9b8f811cfad53b38616cf","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1513119498000},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1513119498000},{"_id":"themes/hiker/layout/_partial/post/urlconvert.ejs","hash":"2133f1029632417f9043b9d4749d580ed0c75db0","modified":1513119498000},{"_id":"source/_posts/docker-101-mod3/docker-compose.gif","hash":"30cd0a56a78e6e814c4318a2834658940a435b13","modified":1513223464000},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1513119498000},{"_id":"themes/hiker/source/css/images/about-3.jpg","hash":"f01d49c347be933ec4d57b63ba6cd885d61740f8","modified":1513244146000},{"_id":"themes/hiker/source/css/images/home-bg-1.jpg","hash":"3505df5111300175658689620690bfd3d0e867ca","modified":1513152969000},{"_id":"themes/hiker/source/css/images/about-2.jpg","hash":"364e5ca133abab0ba44dacafb3c1f7f0fe49e682","modified":1513244344000},{"_id":"themes/hiker/source/css/images/about-1.jpg","hash":"b32bf92ab55c8e6123ea21eeb3e7faf72e696b9f","modified":1513244032000},{"_id":"source/_posts/docker-101-mod1/docker-pull.gif","hash":"fc44f2b49e7d38d11dd431766488dd8ffaf7b611","modified":1513223462000},{"_id":"themes/hiker/source/css/images/home-bg-2.jpg","hash":"d63fda56afcd5fd0d280b1f3c6d2f793b499323d","modified":1513152369000},{"_id":"themes/hiker/source/css/images/home-bg-3.jpg","hash":"e7c0d3d6a65c02ce59132619e6909342b125fec6","modified":1513153206000},{"_id":"source/_posts/docker-101-mod3/docker-compose-up.gif","hash":"c8b6c75d66d852eb19fcd30c54022c62228ecd02","modified":1513223464000},{"_id":"source/_posts/docker-101-mod2/docker-build.gif","hash":"c6ce1a4fafbab80daf5f85292280a6ac05527346","modified":1513223463000},{"_id":"source/_posts/docker-101-mod1/docker-run.gif","hash":"7b9d4fa551515c39e6c492f9620cb21d2c9fb3c9","modified":1513223463000},{"_id":"source/_posts/docker-101-mod2/docker-run-new.gif","hash":"d973ee8971624988ef42921abf84f5b1968720f5","modified":1513223464000},{"_id":"source/about/index/github.png","hash":"67e944ac30d86d46af48961ae2be0543da140887","modified":1513369500000},{"_id":"source/about/index/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1513372394000},{"_id":"source/about/index/docker.png","hash":"4680c9ef24945ac341f8aae1cc83d244d8db6441","modified":1513373997000},{"_id":"source/about/index/instagram.png","hash":"581732a7efa3da4c4a517b2662611cd4e2c1394b","modified":1513370941000},{"_id":"source/about/index/email.png","hash":"06da1fd369f342094c1348193a5f09432aef1849","modified":1513370965000},{"_id":"source/about/index/linkedin.png","hash":"2c34194fffb17384b65c7bf819db2d6e9064bcfc","modified":1513370573000},{"_id":"source/about/index/resume.png","hash":"60ad267ea0cf687ab8be0ef2f3871d1c9c742df0","modified":1513372341000},{"_id":"source/about/index/twitter.png","hash":"09b0e931367c2419f305cdb20050fa05ab7cd6e1","modified":1513370924000},{"_id":"source/about/index/rss.png","hash":"c830450a96263f11a6d103027a92faee1462afc5","modified":1513370978000}],"Category":[{"name":"tutorials","_id":"cjb8926hl0002pbmlfbglaw9m"},{"name":"docker","_id":"cjb8926jy000jpbml2p0pvx0g"}],"Data":[],"Page":[{"title":"About","date":"2017-12-14T17:19:19.000Z","_content":"\n[![Online Resume](index/resume.png)](http://mayank.tahil.site) | [![@Mayanktahil](index/github.png)](https://github.com/mayanktahil) | [![@Mayanktahil](index/linkedin.png)](https://www.linkedin.com/in/mayanktahil/) | [![@Mayanktahil](index/twitter.png)](https://twitter.com/mayanktahil?lang=en) | [![@Mayanktahil](index/instagram.png)](https://www.instagram.com/mayanktahil/) | [![Send Mail](index/email.png)](mailto:mayank.tahil-AT-gmail.com) | [![RSS Feed](index/rss.png)](http://blog.tahil.site/atom.xml) | [![@mayankt](index/docker.png)](https://hub.docker.com/u/mayankt/)\n:---: | :---: | :---: | :---: | :---: | :---: | :---: | :---:\n\n\n# Introduction \n\nThis blog originally started off as a weekend side project to learn more about front end development and to get my hands dirty with HTML, CSS, JavaScript, and AngularJS. After about a day, I realize just how easy modern tools have made it to quickly create beautiful, functioning websites. In a nutshell, this blog will serve to host content I've been originally stowing away in `README.MD` files within my GitHub repositories. Now I'd like legitimize them into online technical tutorials for the community to consume. However, this blog won't  focus *only* on technical 'how-to's' rather it will also be focusing on new and emerging technologies within the [container](https://en.wikipedia.org/wiki/Operating-system-level_virtualization) and [cloud](https://en.wikipedia.org/wiki/Cloud_computing) space. You can expect to see my personal opinions on start-ups and automation tools as they emerge into popularity. \n\n# Background\n\nMy education background is in Biochemistry with a focus on Neuro-engineering but professionally I work within IT as an experienced tech specialist who isn't afraid to automate anything and everything. I've been customer facing most of my career with marked experience in Pre-Sales, Customer Service, Networking, Cloud, Docker, and Automation. I consider myself a strong advocate of Open Source Software (OSS), Open Source Knowledge Sharing, and the ongoing shift of agile transformation at the data center and in the cloud. If I'm not working, you can likely find me walking my dog or exploring around the city. You can find out more about me by visiting my [online resume](http://mayank.tahil.site]. \n\n# Offline Blog \n\nIf you have docker locally installed, you can steal a portable, lightweight, off line copy of this blog by following the steps below. \n\n## From Docker Hub\n\nTo pull a ready made image from my docker hub account, execute the following : \n\n```bash\ndocker run -it --rm mayankt/blog:tahil-site\n```\n\n> You can abort hosting the site by pressing `ctrl` + `c` to quit terminal task execution. \n\nNavigate to [localhost](http://localhost) to view the contents of the blog in your web browser \n\n## From GitHub\n\nYou can clone this blog and create your own local docker image by executing : \n\n```bash\n# Clone the repository locally\ngit clone https://github.com/MayankTahil/blog.tahil.site.git\n\n# Enter repository \ncd blog.tahil.site\n\n# Create your container image\ndocker build -f blog.tahil.site-lite.dockerfile -t mayankt/blog:tahil-site .\n\n# Run your docker container\ndocker run -it --rm -p 80:80 mayankt/blog:tahil-site\n```\n\n> You can abort hosting the site by pressing `ctrl` + `c` to quit terminal task execution. \n\nNavigate to [localhost](http://localhost) to view the contents of the blog in your web browser \n\n\n# Global Notice\n\nThe owner/authors of this blog make no representations as to the accuracy or completeness of any information on this site or found by following any link on this site. The owner will not be liable for any errors or omissions in this information nor for the availability of this information. The owner will not be liable for any losses, injuries, or damages from the display or use of this information. All content in this blog is of the author's opinion and does not represent in any way his/her employer's nor any other corporation's opinion. These terms and conditions of use are subject to change at any time and without notice.\n\n\n\n\n\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2017-12-14 09:19:19\n---\n\n[![Online Resume](index/resume.png)](http://mayank.tahil.site) | [![@Mayanktahil](index/github.png)](https://github.com/mayanktahil) | [![@Mayanktahil](index/linkedin.png)](https://www.linkedin.com/in/mayanktahil/) | [![@Mayanktahil](index/twitter.png)](https://twitter.com/mayanktahil?lang=en) | [![@Mayanktahil](index/instagram.png)](https://www.instagram.com/mayanktahil/) | [![Send Mail](index/email.png)](mailto:mayank.tahil-AT-gmail.com) | [![RSS Feed](index/rss.png)](http://blog.tahil.site/atom.xml) | [![@mayankt](index/docker.png)](https://hub.docker.com/u/mayankt/)\n:---: | :---: | :---: | :---: | :---: | :---: | :---: | :---:\n\n\n# Introduction \n\nThis blog originally started off as a weekend side project to learn more about front end development and to get my hands dirty with HTML, CSS, JavaScript, and AngularJS. After about a day, I realize just how easy modern tools have made it to quickly create beautiful, functioning websites. In a nutshell, this blog will serve to host content I've been originally stowing away in `README.MD` files within my GitHub repositories. Now I'd like legitimize them into online technical tutorials for the community to consume. However, this blog won't  focus *only* on technical 'how-to's' rather it will also be focusing on new and emerging technologies within the [container](https://en.wikipedia.org/wiki/Operating-system-level_virtualization) and [cloud](https://en.wikipedia.org/wiki/Cloud_computing) space. You can expect to see my personal opinions on start-ups and automation tools as they emerge into popularity. \n\n# Background\n\nMy education background is in Biochemistry with a focus on Neuro-engineering but professionally I work within IT as an experienced tech specialist who isn't afraid to automate anything and everything. I've been customer facing most of my career with marked experience in Pre-Sales, Customer Service, Networking, Cloud, Docker, and Automation. I consider myself a strong advocate of Open Source Software (OSS), Open Source Knowledge Sharing, and the ongoing shift of agile transformation at the data center and in the cloud. If I'm not working, you can likely find me walking my dog or exploring around the city. You can find out more about me by visiting my [online resume](http://mayank.tahil.site]. \n\n# Offline Blog \n\nIf you have docker locally installed, you can steal a portable, lightweight, off line copy of this blog by following the steps below. \n\n## From Docker Hub\n\nTo pull a ready made image from my docker hub account, execute the following : \n\n```bash\ndocker run -it --rm mayankt/blog:tahil-site\n```\n\n> You can abort hosting the site by pressing `ctrl` + `c` to quit terminal task execution. \n\nNavigate to [localhost](http://localhost) to view the contents of the blog in your web browser \n\n## From GitHub\n\nYou can clone this blog and create your own local docker image by executing : \n\n```bash\n# Clone the repository locally\ngit clone https://github.com/MayankTahil/blog.tahil.site.git\n\n# Enter repository \ncd blog.tahil.site\n\n# Create your container image\ndocker build -f blog.tahil.site-lite.dockerfile -t mayankt/blog:tahil-site .\n\n# Run your docker container\ndocker run -it --rm -p 80:80 mayankt/blog:tahil-site\n```\n\n> You can abort hosting the site by pressing `ctrl` + `c` to quit terminal task execution. \n\nNavigate to [localhost](http://localhost) to view the contents of the blog in your web browser \n\n\n# Global Notice\n\nThe owner/authors of this blog make no representations as to the accuracy or completeness of any information on this site or found by following any link on this site. The owner will not be liable for any errors or omissions in this information nor for the availability of this information. The owner will not be liable for any losses, injuries, or damages from the display or use of this information. All content in this blog is of the author's opinion and does not represent in any way his/her employer's nor any other corporation's opinion. These terms and conditions of use are subject to change at any time and without notice.\n\n\n\n\n\n","updated":"2017-12-15T21:56:48.000Z","path":"about/index.html","_id":"cjb8926jm000cpbml0p13by0j","comments":1,"layout":"page","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"http://mayank.tahil.site\" target=\"_blank\" rel=\"noopener\"><img src=\"index/resume.png\" alt=\"Online Resume\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://github.com/mayanktahil\" target=\"_blank\" rel=\"noopener\"><img src=\"index/github.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://www.linkedin.com/in/mayanktahil/\" target=\"_blank\" rel=\"noopener\"><img src=\"index/linkedin.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://twitter.com/mayanktahil?lang=en\" target=\"_blank\" rel=\"noopener\"><img src=\"index/twitter.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://www.instagram.com/mayanktahil/\" target=\"_blank\" rel=\"noopener\"><img src=\"index/instagram.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"mailto:mayank.tahil-AT-gmail.com\" target=\"_blank\" rel=\"noopener\"><img src=\"index/email.png\" alt=\"Send Mail\"></a></th>\n<th style=\"text-align:center\"><a href=\"http://blog.tahil.site/atom.xml\"><img src=\"index/rss.png\" alt=\"RSS Feed\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://hub.docker.com/u/mayankt/\" target=\"_blank\" rel=\"noopener\"><img src=\"index/docker.png\" alt=\"@mayankt\"></a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Introduction</h1>\n<p>This blog originally started off as a weekend side project to learn more about front end development and to get my hands dirty with HTML, CSS, JavaScript, and AngularJS. After about a day, I realize just how easy modern tools have made it to quickly create beautiful, functioning websites. In a nutshell, this blog will serve to host content I’ve been originally stowing away in <code>README.MD</code> files within my GitHub repositories. Now I’d like legitimize them into online technical tutorials for the community to consume. However, this blog won’t  focus <em>only</em> on technical ‘how-to’s’ rather it will also be focusing on new and emerging technologies within the <a href=\"https://en.wikipedia.org/wiki/Operating-system-level_virtualization\" target=\"_blank\" rel=\"noopener\">container</a> and <a href=\"https://en.wikipedia.org/wiki/Cloud_computing\" target=\"_blank\" rel=\"noopener\">cloud</a> space. You can expect to see my personal opinions on start-ups and automation tools as they emerge into popularity.</p>\n<h1>Background</h1>\n<p>My education background is in Biochemistry with a focus on Neuro-engineering but professionally I work within IT as an experienced tech specialist who isn’t afraid to automate anything and everything. I’ve been customer facing most of my career with marked experience in Pre-Sales, Customer Service, Networking, Cloud, Docker, and Automation. I consider myself a strong advocate of Open Source Software (OSS), Open Source Knowledge Sharing, and the ongoing shift of agile transformation at the data center and in the cloud. If I’m not working, you can likely find me walking my dog or exploring around the city. You can find out more about me by visiting my [online resume](<a href=\"http://mayank.tahil.site\" target=\"_blank\" rel=\"noopener\">http://mayank.tahil.site</a>].</p>\n<h1>Offline Blog</h1>\n<p>If you have docker locally installed, you can steal a portable, lightweight, off line copy of this blog by following the steps below.</p>\n<h2>From Docker Hub</h2>\n<p>To pull a ready made image from my docker hub account, execute the following :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --rm mayankt/blog:tahil-site</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>You can abort hosting the site by pressing <code>ctrl</code> + <code>c</code> to quit terminal task execution.</p>\n</blockquote>\n<p>Navigate to <a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">localhost</a> to view the contents of the blog in your web browser</p>\n<h2>From GitHub</h2>\n<p>You can clone this blog and create your own local docker image by executing :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Clone the repository locally</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/MayankTahil/blog.tahil.site.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enter repository </span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> blog.tahil.site</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create your container image</span></span><br><span class=\"line\">docker build -f blog.tahil.site-lite.dockerfile -t mayankt/blog:tahil-site .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Run your docker container</span></span><br><span class=\"line\">docker run -it --rm -p 80:80 mayankt/blog:tahil-site</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>You can abort hosting the site by pressing <code>ctrl</code> + <code>c</code> to quit terminal task execution.</p>\n</blockquote>\n<p>Navigate to <a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">localhost</a> to view the contents of the blog in your web browser</p>\n<h1>Global Notice</h1>\n<p>The owner/authors of this blog make no representations as to the accuracy or completeness of any information on this site or found by following any link on this site. The owner will not be liable for any errors or omissions in this information nor for the availability of this information. The owner will not be liable for any losses, injuries, or damages from the display or use of this information. All content in this blog is of the author’s opinion and does not represent in any way his/her employer’s nor any other corporation’s opinion. These terms and conditions of use are subject to change at any time and without notice.</p>\n","site":{"data":{}},"hexoIncludeMarkdown":{"markdown":[]},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"http://mayank.tahil.site\" target=\"_blank\" rel=\"noopener\"><img src=\"index/resume.png\" alt=\"Online Resume\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://github.com/mayanktahil\" target=\"_blank\" rel=\"noopener\"><img src=\"index/github.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://www.linkedin.com/in/mayanktahil/\" target=\"_blank\" rel=\"noopener\"><img src=\"index/linkedin.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://twitter.com/mayanktahil?lang=en\" target=\"_blank\" rel=\"noopener\"><img src=\"index/twitter.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://www.instagram.com/mayanktahil/\" target=\"_blank\" rel=\"noopener\"><img src=\"index/instagram.png\" alt=\"@Mayanktahil\"></a></th>\n<th style=\"text-align:center\"><a href=\"mailto:mayank.tahil-AT-gmail.com\" target=\"_blank\" rel=\"noopener\"><img src=\"index/email.png\" alt=\"Send Mail\"></a></th>\n<th style=\"text-align:center\"><a href=\"http://blog.tahil.site/atom.xml\"><img src=\"index/rss.png\" alt=\"RSS Feed\"></a></th>\n<th style=\"text-align:center\"><a href=\"https://hub.docker.com/u/mayankt/\" target=\"_blank\" rel=\"noopener\"><img src=\"index/docker.png\" alt=\"@mayankt\"></a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Introduction</h1>\n<p>This blog originally started off as a weekend side project to learn more about front end development and to get my hands dirty with HTML, CSS, JavaScript, and AngularJS. After about a day, I realize just how easy modern tools have made it to quickly create beautiful, functioning websites. In a nutshell, this blog will serve to host content I’ve been originally stowing away in <code>README.MD</code> files within my GitHub repositories. Now I’d like legitimize them into online technical tutorials for the community to consume. However, this blog won’t  focus <em>only</em> on technical ‘how-to’s’ rather it will also be focusing on new and emerging technologies within the <a href=\"https://en.wikipedia.org/wiki/Operating-system-level_virtualization\" target=\"_blank\" rel=\"noopener\">container</a> and <a href=\"https://en.wikipedia.org/wiki/Cloud_computing\" target=\"_blank\" rel=\"noopener\">cloud</a> space. You can expect to see my personal opinions on start-ups and automation tools as they emerge into popularity.</p>\n<h1>Background</h1>\n<p>My education background is in Biochemistry with a focus on Neuro-engineering but professionally I work within IT as an experienced tech specialist who isn’t afraid to automate anything and everything. I’ve been customer facing most of my career with marked experience in Pre-Sales, Customer Service, Networking, Cloud, Docker, and Automation. I consider myself a strong advocate of Open Source Software (OSS), Open Source Knowledge Sharing, and the ongoing shift of agile transformation at the data center and in the cloud. If I’m not working, you can likely find me walking my dog or exploring around the city. You can find out more about me by visiting my [online resume](<a href=\"http://mayank.tahil.site\" target=\"_blank\" rel=\"noopener\">http://mayank.tahil.site</a>].</p>\n<h1>Offline Blog</h1>\n<p>If you have docker locally installed, you can steal a portable, lightweight, off line copy of this blog by following the steps below.</p>\n<h2>From Docker Hub</h2>\n<p>To pull a ready made image from my docker hub account, execute the following :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -it --rm mayankt/blog:tahil-site</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>You can abort hosting the site by pressing <code>ctrl</code> + <code>c</code> to quit terminal task execution.</p>\n</blockquote>\n<p>Navigate to <a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">localhost</a> to view the contents of the blog in your web browser</p>\n<h2>From GitHub</h2>\n<p>You can clone this blog and create your own local docker image by executing :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Clone the repository locally</span></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/MayankTahil/blog.tahil.site.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Enter repository </span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> blog.tahil.site</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create your container image</span></span><br><span class=\"line\">docker build -f blog.tahil.site-lite.dockerfile -t mayankt/blog:tahil-site .</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Run your docker container</span></span><br><span class=\"line\">docker run -it --rm -p 80:80 mayankt/blog:tahil-site</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>You can abort hosting the site by pressing <code>ctrl</code> + <code>c</code> to quit terminal task execution.</p>\n</blockquote>\n<p>Navigate to <a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">localhost</a> to view the contents of the blog in your web browser</p>\n<h1>Global Notice</h1>\n<p>The owner/authors of this blog make no representations as to the accuracy or completeness of any information on this site or found by following any link on this site. The owner will not be liable for any errors or omissions in this information nor for the availability of this information. The owner will not be liable for any losses, injuries, or damages from the display or use of this information. All content in this blog is of the author’s opinion and does not represent in any way his/her employer’s nor any other corporation’s opinion. These terms and conditions of use are subject to change at any time and without notice.</p>\n"}],"Post":[{"title":"Introduction to Docker Images and Containers","date":"2017-12-15T01:28:29.000Z","show":false,"_content":"\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n# Module 1: Running Docker Containers\n\n{% post_link slug \"Introduction to Docker\" %}\n\n\nOnce you have Docker installed locally, you can verify your installation by simply typing \n\n```\ndocker --version\n```\n\nto see an output similar to: \n\n```\nDocker version 17.06.0-ce, build 02c1d87\n```\n  > If you get a permissions errors on your local docker machine, type `sudo docker --version` to complete the task. The current user must be in [sudoers or docker group](https://docs.docker.com/engine/installation/linux/linux-postinstall/) to execute docker commands. \n\n<!-- more --> \n\n## Docker Images \n\nAll Docker containers are based off [Docker images](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/). Docker images are built up from a series of layers. Each layer represents an instruction or resulting block storage changes to the container's filesystem. Each layer except the very last one is read-only, so once an image is made, any changes to data in a running container are made on a separate R/W layer. Think of it as application layering where the first image layer is always a blank minimalistic starting block from [scratch](https://hub.docker.com/_/scratch/) and changes are done by installing dependencies or applications that you desire to package with your docker image. See the visual below to illustrate the concept of image layering: \n\n  {% asset_img docker-images.png Docker Image %}\n\nYou can store docker images in several places: \n\n  * [1. Docker Hub](https://hub.docker.com/explore/)\n  * [2. Other Public Repositories](https://quay.io/tour/)\n  * [3. Locally on your machine](http://blog.thoward37.me/articles/where-are-docker-images-stored/)\n  * [4. Private Docker registries](https://docs.docker.com/registry/deploying/#storage-customization)\n  * [5. In a tar archive](https://docs.docker.com/engine/reference/commandline/save/)\n\n In this tutorial we will mainly be concerning ourselves with **#1** where we are pulling images from Docker Hub.\n\n---\n\n## Exercise 1 : Pulling Docker Images\n\nBefore any container is run, a copy of the docker image is always stored locally on the host. In this exercise we will pull a docker image from docker hub onto the docker host. \n\n### Step 1 : Pull an Image from Docker Hub\n\nTo pull an image down locally onto a host, run the following command: \n\n```\ndocker pull mayankt/webserver:a\n```\n\nHere is a break down of the command as follows: \n\nCommand |  | Details\n--- | --- | ---\n`docker pull` | | This docker command that tells docker engine to pull an image down from somewhere\n`mayankt/webserver:a` | | This is the image name. By default, if a full FQDN is not specified, it is assumed you are pulling the image from docker hub. In this case, you will be pulling an image from my repository [mayankt](https://hub.docker.com/r/mayankt/webserver/) with an image titled `webserver` with the tag of `a`. [Tagging](https://www.techrepublic.com/article/how-to-use-docker-tags-to-add-version-control-to-images/) images can help with versioning of your docker images and many other CI/CD use cases as well. \n\n Once you run the command you should see an output similar to this: \n\n```bash\nPulling from mayankt/webserver\n3ac0c2aa6889: Pull complete \nec2ec713dc4f: Pull complete \nea0a5af9851c: Pull complete \n555bf6439b47: Pull complete \n71080d75d6eb: Pull complete \nc787ac6d0b0a: Pull complete \n1a9841bc3a47: Pull complete \n1a7ce5d6010a: Pull complete \neec46f0642a8: Pull complete \nd2d3a856c0da: Pull complete \nf128b2a739b4: Pull complete \n1341f98ff817: Pull complete \n```\n\nWhich indicates that the image is being pulled from docker hub locally onto your docker host. \n\n### Step 2 : List Local Docker Images\n\nType the following command to see a list of all images stored locally on your host.\n\n```bash\ndocker images\n```\n\nYour output should resemble : \n\n```bash\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmayankt/webserver   a                   18f05d0cd921        2 months ago        27.9MB\n```\n\nThis output shows a 27.9 MB large docker image stored locally that can be run into instances of docker containers. All the `f128b2a739b4: Pull complete` outputs from the `docker pull` command above are the layers being pulled from Docker Hub of which constitute the `mayankt/webserver:a` docker image.\n\n### Review\n\nA simple `docker pull < image-name > ` commands shows how you can pull a docker image from the cloud directly. It's not used until you run a container with it which we will do in the [next Exercise](../Exercise-2).\n\n {% asset_img docker-pull.gif Docker pull from Docker Hub %}\n\n---\n\n## Exercise 2 : Running a Docker Container\n\nLets convert a docker image into a running instance of a docker container to host a simple website.\n\n### Step 1 : Run a Docker Container\n\nWe will issue [`docker run`](https://docs.docker.com/engine/reference/run/) commands to run containers. Type the following command to host a website on the docker host on port `10000`.  \n\n```bash\ndocker run -dt --restart=always --name=cpx-blog -p 10000:80 mayankt/cpx-blog\n```\n\nHere is the breakdown of the command from above:\n\nCommand | | Details\n--- | | ---\n`docker run -dt` | | This will run the container detached in the background. Later we will see [how we can attach to this container's terminal](https://stackoverflow.com/questions/30172605/how-to-get-into-a-docker-container), but for now we will have the container running detached in the background as a daemon.\n`--restart=always` | | This will restart the container automatically if it crashes or if and when docker/host restart.\n`--name=cpx-blog` | | This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container.\n`-p 10000:80` | | This will expose port `10000` on the host and map it to port `80` on the container for access to the hosted website.\n`mayankt/cpx-blog` | | This identifies the `latest` tagged image by default because no explicit tag is specified. It will be pulled from dockerhub to use when running the container. **Note:** It is not necessary to pull a desired image before executing a `docker run` command. If the image does not exist locally, it will be automatically pulled from the designated registry (Docker Hub in our case).\n\nOnce you have entered the command, you will notice an output similar to below:\n\n```bash\nUnable to find image 'mayankt/cpx-blog:latest' locally\nlatest: Pulling from mayankt/cpx-blog\n3ac0c2aa6889: Already exists\nec2ec713dc4f: Already exists\nea0a5af9851c: Already exists\n555bf6439b47: Already exists\n71080d75d6eb: Already exists\nc787ac6d0b0a: Already exists\n1a9841bc3a47: Already exists\n336c032aec9b: Pull complete\nbc3b4209c6c5: Pull complete\n3a5d33d6e1e0: Pull complete\n7e846adb4c7d: Pull complete\nDigest: sha256:141100857249a391261edf7335ffea1ca20478a15d3ac08c821561e7a8998ef9\nStatus: Downloaded newer image for mayankt/cpx-blog:latest\n222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c\n```\n   > Notice some of the layers already exist locally from our previous webserver-a pull because both images use mutual base images that can be recycled and save on local space. Only deltas or layers that make cpx-blog unique from webserver-a are pulled that are not stored locally. Also the output provided in the last line `222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c` is the long unique id of the running container that can be referenced in future docker commands alternative to `cpx-blog`.\n\n### Step 2 : List all Running Containers\n\nTo see all of your running containers type the following command:\n\n```bash\ndocker ps\n```\n\nThat will yield an output similar to below.\n\n```bash\nCONTAINER ID        IMAGE               COMMAND                CREATED              STATUS              PORTS                            NAMES\n222bcc574700        mayankt/cpx-blog    \"/bin/sh -c 'nginx'\"   About a minute ago   Up About a minute   443/tcp, 0.0.0.0:10000->80/tcp   cpx-blog\n```\n\nThis shows that the container named cpx-blog is running based on the image mayankt/cpx-blog with an external 10000 port exposed on the local host for remote access. Navigate to [`htt://localhost:10000`](http://localhost:1000) to see the website.\n\nTo stop your running container, type the following command:\n\n```bash\ndocker stop cpx-blog\n```\n\nNow to see all of your running and **non running** containers, type the following command:\n\n````bash\ndocker ps -a\n```\n\nThat will yield an output similar to below.\n\n```bash\nCONTAINER ID        IMAGE                 COMMAND                CREATED             STATUS                       PORTS               NAMES\nf407d06318f0        mayankt/cpx-blog   \"/bin/sh -c 'nginx'\"   10 minutes ago      Exited (137) 3 seconds ago                       cpx-blog\n```\n\n### Step 3 : Enter Container's Shell\n\nIf you container is not running already, start the container with the following command:\n\n```bash\ndocker start cpx-blog\n```\n\nThen type the following command to enter the terminal shell of the container:\n\n```bash\ndocker exec -it cpx-blog /bin/sh\n```\n\nThe breakdown of the command as follows:\n\nCommand | | Details\n--- | | ---\n`docker exec -it` | | This will execute a command on the container with an interactive terminal (`-it`). We could execute commands in the background with a `-dt` if we wanted to, but we wouldn't see the outcome and the command we're running in this example is invoking a shell. If we wanted to run a script and not interact with it, we could have used the `-dt` flag.  \n`cpx-blog` | | This denotes to which running container to execute the command against. In our case, it's the cpx-blog container.\n`/bin/sh` | | This is the command itself that we want to execute in the container. In this example we are invoking the shell for terminal access into our container. In other examples we could execute specific scripts or bash files as well (i.e. `/var/scripts/init-db.sh` or any other file locally stored within the container).\n\nAfter executing the command, you should have entered into the shell prompt of the container itself. Lets manipulate some files inside the container and see them reflected onto the website.\n\nWithin the container shell, enter the following:\n\n```\nvi /var/wwww/index.html\n```\n\n  > `vi` invokes a CLI text editor. It is functionally the same thing as notepad or sublime text, but geared for CLI interfaces not GUI interfaces. `vi` utility helps edit files in the terminal.\n\nOnce you have opened the `index.html` file, scroll down and change the text between :\n\n```\n<h1 class=\"brand-title\">NetScaler NITRO Blogs</h1>\n```\n\n...to anything you desire, such as :\n\n```\n<h1 class=\"brand-title\">LEARN DOCKER!</h1>\n```\n\n  > Edit text by entering the `i` key and then navigating the cursor to delete text you want to remove then typing in text you want to replace it with. Once completed, hit the `esc` key then `shift` + `:` key. Type `wq` to write and quit. You can then hit `ctrl` + `l` to clear the screen if you desire.\n\nOnce back into the container's CLI, simply type `exit` to logout and return back to the host's terminal.\n\nOnce the `index.html` is updated, refresh your browser or navigate back to [`http://localhost:10000`](http://localhost:10000) to observer changes to your site.\n\n### Review\n\nThis concludes how to run a container with `docker run` command, how to attach to a container's terminal via the `docker exec -it` command, and how to manipulate data within a running container.\n\n {% asset_img docker-run.gif Running Docker Container %}","source":"_posts/docker-101-mod1.md","raw":"---\ntitle: Introduction to Docker Images and Containers\ntag:\n - [docker]\n - [docker-cli]\n - [docker images]\n - [docker 101]\ncategory:\n  - [tutorials]\ndate: 2017-12-14 17:28:29\nshow: false\n---\n\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n# Module 1: Running Docker Containers\n\n{% post_link slug \"Introduction to Docker\" %}\n\n\nOnce you have Docker installed locally, you can verify your installation by simply typing \n\n```\ndocker --version\n```\n\nto see an output similar to: \n\n```\nDocker version 17.06.0-ce, build 02c1d87\n```\n  > If you get a permissions errors on your local docker machine, type `sudo docker --version` to complete the task. The current user must be in [sudoers or docker group](https://docs.docker.com/engine/installation/linux/linux-postinstall/) to execute docker commands. \n\n<!-- more --> \n\n## Docker Images \n\nAll Docker containers are based off [Docker images](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/). Docker images are built up from a series of layers. Each layer represents an instruction or resulting block storage changes to the container's filesystem. Each layer except the very last one is read-only, so once an image is made, any changes to data in a running container are made on a separate R/W layer. Think of it as application layering where the first image layer is always a blank minimalistic starting block from [scratch](https://hub.docker.com/_/scratch/) and changes are done by installing dependencies or applications that you desire to package with your docker image. See the visual below to illustrate the concept of image layering: \n\n  {% asset_img docker-images.png Docker Image %}\n\nYou can store docker images in several places: \n\n  * [1. Docker Hub](https://hub.docker.com/explore/)\n  * [2. Other Public Repositories](https://quay.io/tour/)\n  * [3. Locally on your machine](http://blog.thoward37.me/articles/where-are-docker-images-stored/)\n  * [4. Private Docker registries](https://docs.docker.com/registry/deploying/#storage-customization)\n  * [5. In a tar archive](https://docs.docker.com/engine/reference/commandline/save/)\n\n In this tutorial we will mainly be concerning ourselves with **#1** where we are pulling images from Docker Hub.\n\n---\n\n## Exercise 1 : Pulling Docker Images\n\nBefore any container is run, a copy of the docker image is always stored locally on the host. In this exercise we will pull a docker image from docker hub onto the docker host. \n\n### Step 1 : Pull an Image from Docker Hub\n\nTo pull an image down locally onto a host, run the following command: \n\n```\ndocker pull mayankt/webserver:a\n```\n\nHere is a break down of the command as follows: \n\nCommand |  | Details\n--- | --- | ---\n`docker pull` | | This docker command that tells docker engine to pull an image down from somewhere\n`mayankt/webserver:a` | | This is the image name. By default, if a full FQDN is not specified, it is assumed you are pulling the image from docker hub. In this case, you will be pulling an image from my repository [mayankt](https://hub.docker.com/r/mayankt/webserver/) with an image titled `webserver` with the tag of `a`. [Tagging](https://www.techrepublic.com/article/how-to-use-docker-tags-to-add-version-control-to-images/) images can help with versioning of your docker images and many other CI/CD use cases as well. \n\n Once you run the command you should see an output similar to this: \n\n```bash\nPulling from mayankt/webserver\n3ac0c2aa6889: Pull complete \nec2ec713dc4f: Pull complete \nea0a5af9851c: Pull complete \n555bf6439b47: Pull complete \n71080d75d6eb: Pull complete \nc787ac6d0b0a: Pull complete \n1a9841bc3a47: Pull complete \n1a7ce5d6010a: Pull complete \neec46f0642a8: Pull complete \nd2d3a856c0da: Pull complete \nf128b2a739b4: Pull complete \n1341f98ff817: Pull complete \n```\n\nWhich indicates that the image is being pulled from docker hub locally onto your docker host. \n\n### Step 2 : List Local Docker Images\n\nType the following command to see a list of all images stored locally on your host.\n\n```bash\ndocker images\n```\n\nYour output should resemble : \n\n```bash\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nmayankt/webserver   a                   18f05d0cd921        2 months ago        27.9MB\n```\n\nThis output shows a 27.9 MB large docker image stored locally that can be run into instances of docker containers. All the `f128b2a739b4: Pull complete` outputs from the `docker pull` command above are the layers being pulled from Docker Hub of which constitute the `mayankt/webserver:a` docker image.\n\n### Review\n\nA simple `docker pull < image-name > ` commands shows how you can pull a docker image from the cloud directly. It's not used until you run a container with it which we will do in the [next Exercise](../Exercise-2).\n\n {% asset_img docker-pull.gif Docker pull from Docker Hub %}\n\n---\n\n## Exercise 2 : Running a Docker Container\n\nLets convert a docker image into a running instance of a docker container to host a simple website.\n\n### Step 1 : Run a Docker Container\n\nWe will issue [`docker run`](https://docs.docker.com/engine/reference/run/) commands to run containers. Type the following command to host a website on the docker host on port `10000`.  \n\n```bash\ndocker run -dt --restart=always --name=cpx-blog -p 10000:80 mayankt/cpx-blog\n```\n\nHere is the breakdown of the command from above:\n\nCommand | | Details\n--- | | ---\n`docker run -dt` | | This will run the container detached in the background. Later we will see [how we can attach to this container's terminal](https://stackoverflow.com/questions/30172605/how-to-get-into-a-docker-container), but for now we will have the container running detached in the background as a daemon.\n`--restart=always` | | This will restart the container automatically if it crashes or if and when docker/host restart.\n`--name=cpx-blog` | | This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container.\n`-p 10000:80` | | This will expose port `10000` on the host and map it to port `80` on the container for access to the hosted website.\n`mayankt/cpx-blog` | | This identifies the `latest` tagged image by default because no explicit tag is specified. It will be pulled from dockerhub to use when running the container. **Note:** It is not necessary to pull a desired image before executing a `docker run` command. If the image does not exist locally, it will be automatically pulled from the designated registry (Docker Hub in our case).\n\nOnce you have entered the command, you will notice an output similar to below:\n\n```bash\nUnable to find image 'mayankt/cpx-blog:latest' locally\nlatest: Pulling from mayankt/cpx-blog\n3ac0c2aa6889: Already exists\nec2ec713dc4f: Already exists\nea0a5af9851c: Already exists\n555bf6439b47: Already exists\n71080d75d6eb: Already exists\nc787ac6d0b0a: Already exists\n1a9841bc3a47: Already exists\n336c032aec9b: Pull complete\nbc3b4209c6c5: Pull complete\n3a5d33d6e1e0: Pull complete\n7e846adb4c7d: Pull complete\nDigest: sha256:141100857249a391261edf7335ffea1ca20478a15d3ac08c821561e7a8998ef9\nStatus: Downloaded newer image for mayankt/cpx-blog:latest\n222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c\n```\n   > Notice some of the layers already exist locally from our previous webserver-a pull because both images use mutual base images that can be recycled and save on local space. Only deltas or layers that make cpx-blog unique from webserver-a are pulled that are not stored locally. Also the output provided in the last line `222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c` is the long unique id of the running container that can be referenced in future docker commands alternative to `cpx-blog`.\n\n### Step 2 : List all Running Containers\n\nTo see all of your running containers type the following command:\n\n```bash\ndocker ps\n```\n\nThat will yield an output similar to below.\n\n```bash\nCONTAINER ID        IMAGE               COMMAND                CREATED              STATUS              PORTS                            NAMES\n222bcc574700        mayankt/cpx-blog    \"/bin/sh -c 'nginx'\"   About a minute ago   Up About a minute   443/tcp, 0.0.0.0:10000->80/tcp   cpx-blog\n```\n\nThis shows that the container named cpx-blog is running based on the image mayankt/cpx-blog with an external 10000 port exposed on the local host for remote access. Navigate to [`htt://localhost:10000`](http://localhost:1000) to see the website.\n\nTo stop your running container, type the following command:\n\n```bash\ndocker stop cpx-blog\n```\n\nNow to see all of your running and **non running** containers, type the following command:\n\n````bash\ndocker ps -a\n```\n\nThat will yield an output similar to below.\n\n```bash\nCONTAINER ID        IMAGE                 COMMAND                CREATED             STATUS                       PORTS               NAMES\nf407d06318f0        mayankt/cpx-blog   \"/bin/sh -c 'nginx'\"   10 minutes ago      Exited (137) 3 seconds ago                       cpx-blog\n```\n\n### Step 3 : Enter Container's Shell\n\nIf you container is not running already, start the container with the following command:\n\n```bash\ndocker start cpx-blog\n```\n\nThen type the following command to enter the terminal shell of the container:\n\n```bash\ndocker exec -it cpx-blog /bin/sh\n```\n\nThe breakdown of the command as follows:\n\nCommand | | Details\n--- | | ---\n`docker exec -it` | | This will execute a command on the container with an interactive terminal (`-it`). We could execute commands in the background with a `-dt` if we wanted to, but we wouldn't see the outcome and the command we're running in this example is invoking a shell. If we wanted to run a script and not interact with it, we could have used the `-dt` flag.  \n`cpx-blog` | | This denotes to which running container to execute the command against. In our case, it's the cpx-blog container.\n`/bin/sh` | | This is the command itself that we want to execute in the container. In this example we are invoking the shell for terminal access into our container. In other examples we could execute specific scripts or bash files as well (i.e. `/var/scripts/init-db.sh` or any other file locally stored within the container).\n\nAfter executing the command, you should have entered into the shell prompt of the container itself. Lets manipulate some files inside the container and see them reflected onto the website.\n\nWithin the container shell, enter the following:\n\n```\nvi /var/wwww/index.html\n```\n\n  > `vi` invokes a CLI text editor. It is functionally the same thing as notepad or sublime text, but geared for CLI interfaces not GUI interfaces. `vi` utility helps edit files in the terminal.\n\nOnce you have opened the `index.html` file, scroll down and change the text between :\n\n```\n<h1 class=\"brand-title\">NetScaler NITRO Blogs</h1>\n```\n\n...to anything you desire, such as :\n\n```\n<h1 class=\"brand-title\">LEARN DOCKER!</h1>\n```\n\n  > Edit text by entering the `i` key and then navigating the cursor to delete text you want to remove then typing in text you want to replace it with. Once completed, hit the `esc` key then `shift` + `:` key. Type `wq` to write and quit. You can then hit `ctrl` + `l` to clear the screen if you desire.\n\nOnce back into the container's CLI, simply type `exit` to logout and return back to the host's terminal.\n\nOnce the `index.html` is updated, refresh your browser or navigate back to [`http://localhost:10000`](http://localhost:10000) to observer changes to your site.\n\n### Review\n\nThis concludes how to run a container with `docker run` command, how to attach to a container's terminal via the `docker exec -it` command, and how to manipulate data within a running container.\n\n {% asset_img docker-run.gif Running Docker Container %}","slug":"docker-101-mod1","published":1,"updated":"2017-12-15T19:33:06.000Z","_id":"cjb8926h70000pbml7eu444gi","comments":1,"layout":"post","photos":[],"link":"","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Module 1: Running Docker Containers</h1>\n\n<p>Once you have Docker installed locally, you can verify your installation by simply typing</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker --version</span><br></pre></td></tr></table></figure>\n<p>to see an output similar to:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Docker version 17.06.0-ce, build 02c1d87</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>If you get a permissions errors on your local docker machine, type <code>sudo docker --version</code> to complete the task. The current user must be in <a href=\"https://docs.docker.com/engine/installation/linux/linux-postinstall/\" target=\"_blank\" rel=\"noopener\">sudoers or docker group</a> to execute docker commands.</p>\n</blockquote>\n<a id=\"more\"></a> \n<h2>Docker Images</h2>\n<p>All Docker containers are based off <a href=\"https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/\" target=\"_blank\" rel=\"noopener\">Docker images</a>. Docker images are built up from a series of layers. Each layer represents an instruction or resulting block storage changes to the container’s filesystem. Each layer except the very last one is read-only, so once an image is made, any changes to data in a running container are made on a separate R/W layer. Think of it as application layering where the first image layer is always a blank minimalistic starting block from <a href=\"https://hub.docker.com/_/scratch/\" target=\"_blank\" rel=\"noopener\">scratch</a> and changes are done by installing dependencies or applications that you desire to package with your docker image. See the visual below to illustrate the concept of image layering:</p>\n  \n<p>You can store docker images in several places:</p>\n<ul>\n<li><a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">1. Docker Hub</a></li>\n<li><a href=\"https://quay.io/tour/\" target=\"_blank\" rel=\"noopener\">2. Other Public Repositories</a></li>\n<li><a href=\"http://blog.thoward37.me/articles/where-are-docker-images-stored/\" target=\"_blank\" rel=\"noopener\">3. Locally on your machine</a></li>\n<li><a href=\"https://docs.docker.com/registry/deploying/#storage-customization\" target=\"_blank\" rel=\"noopener\">4. Private Docker registries</a></li>\n<li><a href=\"https://docs.docker.com/engine/reference/commandline/save/\" target=\"_blank\" rel=\"noopener\">5. In a tar archive</a></li>\n</ul>\n<p>In this tutorial we will mainly be concerning ourselves with <strong>#1</strong> where we are pulling images from Docker Hub.</p>\n<hr>\n<h2>Exercise 1 : Pulling Docker Images</h2>\n<p>Before any container is run, a copy of the docker image is always stored locally on the host. In this exercise we will pull a docker image from docker hub onto the docker host.</p>\n<h3>Step 1 : Pull an Image from Docker Hub</h3>\n<p>To pull an image down locally onto a host, run the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mayankt/webserver:a</span><br></pre></td></tr></table></figure>\n<p>Here is a break down of the command as follows:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th></th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker pull</code></td>\n<td></td>\n<td>This docker command that tells docker engine to pull an image down from somewhere</td>\n</tr>\n<tr>\n<td><code>mayankt/webserver:a</code></td>\n<td></td>\n<td>This is the image name. By default, if a full FQDN is not specified, it is assumed you are pulling the image from docker hub. In this case, you will be pulling an image from my repository <a href=\"https://hub.docker.com/r/mayankt/webserver/\" target=\"_blank\" rel=\"noopener\">mayankt</a> with an image titled <code>webserver</code> with the tag of <code>a</code>. <a href=\"https://www.techrepublic.com/article/how-to-use-docker-tags-to-add-version-control-to-images/\" target=\"_blank\" rel=\"noopener\">Tagging</a> images can help with versioning of your docker images and many other CI/CD use cases as well.</td>\n</tr>\n</tbody>\n</table>\n<p>Once you run the command you should see an output similar to this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pulling from mayankt/webserver</span><br><span class=\"line\">3ac0c2aa6889: Pull complete </span><br><span class=\"line\">ec2ec713dc4f: Pull complete </span><br><span class=\"line\">ea0a5af9851c: Pull complete </span><br><span class=\"line\">555bf6439b47: Pull complete </span><br><span class=\"line\">71080d75d6eb: Pull complete </span><br><span class=\"line\">c787ac6d0b0a: Pull complete </span><br><span class=\"line\">1a9841bc3a47: Pull complete </span><br><span class=\"line\">1a7ce5d6010a: Pull complete </span><br><span class=\"line\">eec46f0642a8: Pull complete </span><br><span class=\"line\">d2d3a856c0da: Pull complete </span><br><span class=\"line\">f128b2a739b4: Pull complete </span><br><span class=\"line\">1341f98ff817: Pull complete</span><br></pre></td></tr></table></figure>\n<p>Which indicates that the image is being pulled from docker hub locally onto your docker host.</p>\n<h3>Step 2 : List Local Docker Images</h3>\n<p>Type the following command to see a list of all images stored locally on your host.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>Your output should resemble :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">mayankt/webserver   a                   18f05d0cd921        2 months ago        27.9MB</span><br></pre></td></tr></table></figure>\n<p>This output shows a 27.9 MB large docker image stored locally that can be run into instances of docker containers. All the <code>f128b2a739b4: Pull complete</code> outputs from the <code>docker pull</code> command above are the layers being pulled from Docker Hub of which constitute the <code>mayankt/webserver:a</code> docker image.</p>\n<h3>Review</h3>\n<p>A simple <code>docker pull &lt; image-name &gt;</code> commands shows how you can pull a docker image from the cloud directly. It’s not used until you run a container with it which we will do in the <a href=\"../Exercise-2\">next Exercise</a>.</p>\n <img src=\"/docker-101-mod1/docker-pull.gif\" title=\"Docker pull from Docker Hub\">\n<hr>\n<h2>Exercise 2 : Running a Docker Container</h2>\n<p>Lets convert a docker image into a running instance of a docker container to host a simple website.</p>\n<h3>Step 1 : Run a Docker Container</h3>\n<p>We will issue <a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\"><code>docker run</code></a> commands to run containers. Type the following command to host a website on the docker host on port <code>10000</code>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --restart=always --name=cpx-blog -p 10000:80 mayankt/cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the command from above:</p>\n<p>Command | | Details<br>\n— | | —<br>\n<code>docker run -dt</code> | | This will run the container detached in the background. Later we will see <a href=\"https://stackoverflow.com/questions/30172605/how-to-get-into-a-docker-container\" target=\"_blank\" rel=\"noopener\">how we can attach to this container’s terminal</a>, but for now we will have the container running detached in the background as a daemon.<br>\n<code>--restart=always</code> | | This will restart the container automatically if it crashes or if and when docker/host restart.<br>\n<code>--name=cpx-blog</code> | | This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container.<br>\n<code>-p 10000:80</code> | | This will expose port <code>10000</code> on the host and map it to port <code>80</code> on the container for access to the hosted website.<br>\n<code>mayankt/cpx-blog</code> | | This identifies the <code>latest</code> tagged image by default because no explicit tag is specified. It will be pulled from dockerhub to use when running the container. <strong>Note:</strong> It is not necessary to pull a desired image before executing a <code>docker run</code> command. If the image does not exist locally, it will be automatically pulled from the designated registry (Docker Hub in our case).</p>\n<p>Once you have entered the command, you will notice an output similar to below:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unable to find image <span class=\"string\">'mayankt/cpx-blog:latest'</span> locally</span><br><span class=\"line\">latest: Pulling from mayankt/cpx-blog</span><br><span class=\"line\">3ac0c2aa6889: Already exists</span><br><span class=\"line\">ec2ec713dc4f: Already exists</span><br><span class=\"line\">ea0a5af9851c: Already exists</span><br><span class=\"line\">555bf6439b47: Already exists</span><br><span class=\"line\">71080d75d6eb: Already exists</span><br><span class=\"line\">c787ac6d0b0a: Already exists</span><br><span class=\"line\">1a9841bc3a47: Already exists</span><br><span class=\"line\">336c032aec9b: Pull complete</span><br><span class=\"line\">bc3b4209c6c5: Pull complete</span><br><span class=\"line\">3a5d33d6e1e0: Pull complete</span><br><span class=\"line\">7e846adb4c7d: Pull complete</span><br><span class=\"line\">Digest: sha256:141100857249a391261edf7335ffea1ca20478a15d3ac08c821561e7a8998ef9</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> mayankt/cpx-blog:latest</span><br><span class=\"line\">222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Notice some of the layers already exist locally from our previous webserver-a pull because both images use mutual base images that can be recycled and save on local space. Only deltas or layers that make cpx-blog unique from webserver-a are pulled that are not stored locally. Also the output provided in the last line <code>222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c</code> is the long unique id of the running container that can be referenced in future docker commands alternative to <code>cpx-blog</code>.</p>\n</blockquote>\n<h3>Step 2 : List all Running Containers</h3>\n<p>To see all of your running containers type the following command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>That will yield an output similar to below.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS              PORTS                            NAMES</span><br><span class=\"line\">222bcc574700        mayankt/cpx-blog    <span class=\"string\">\"/bin/sh -c 'nginx'\"</span>   About a minute ago   Up About a minute   443/tcp, 0.0.0.0:10000-&gt;80/tcp   cpx-blog</span><br></pre></td></tr></table></figure>\n<p>This shows that the container named cpx-blog is running based on the image mayankt/cpx-blog with an external 10000 port exposed on the local host for remote access. Navigate to <a href=\"http://localhost:1000\" target=\"_blank\" rel=\"noopener\"><code>htt://localhost:10000</code></a> to see the website.</p>\n<p>To stop your running container, type the following command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Now to see all of your running and <strong>non running</strong> containers, type the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n<p>That will yield an output similar to below.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE                 COMMAND                CREATED             STATUS                       PORTS               NAMES</span><br><span class=\"line\">f407d06318f0        mayankt/cpx-blog   <span class=\"string\">\"/bin/sh -c 'nginx'\"</span>   10 minutes ago      Exited (137) 3 seconds ago                       cpx-blog</span><br></pre></td></tr></table></figure>\n<h3>Step 3 : Enter Container’s Shell</h3>\n<p>If you container is not running already, start the container with the following command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Then type the following command to enter the terminal shell of the container:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it cpx-blog /bin/sh</span><br></pre></td></tr></table></figure>\n<p>The breakdown of the command as follows:</p>\n<p>Command | | Details<br>\n— | | —<br>\n<code>docker exec -it</code> | | This will execute a command on the container with an interactive terminal (<code>-it</code>). We could execute commands in the background with a <code>-dt</code> if we wanted to, but we wouldn’t see the outcome and the command we’re running in this example is invoking a shell. If we wanted to run a script and not interact with it, we could have used the <code>-dt</code> flag.<br>\n<code>cpx-blog</code> | | This denotes to which running container to execute the command against. In our case, it’s the cpx-blog container.<br>\n<code>/bin/sh</code> | | This is the command itself that we want to execute in the container. In this example we are invoking the shell for terminal access into our container. In other examples we could execute specific scripts or bash files as well (i.e. <code>/var/scripts/init-db.sh</code> or any other file locally stored within the container).</p>\n<p>After executing the command, you should have entered into the shell prompt of the container itself. Lets manipulate some files inside the container and see them reflected onto the website.</p>\n<p>Within the container shell, enter the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /var/wwww/index.html</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>vi</code> invokes a CLI text editor. It is functionally the same thing as notepad or sublime text, but geared for CLI interfaces not GUI interfaces. <code>vi</code> utility helps edit files in the terminal.</p>\n</blockquote>\n<p>Once you have opened the <code>index.html</code> file, scroll down and change the text between :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;NetScaler NITRO Blogs&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<p>…to anything you desire, such as :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;LEARN DOCKER!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Edit text by entering the <code>i</code> key and then navigating the cursor to delete text you want to remove then typing in text you want to replace it with. Once completed, hit the <code>esc</code> key then <code>shift</code> + <code>:</code> key. Type <code>wq</code> to write and quit. You can then hit <code>ctrl</code> + <code>l</code> to clear the screen if you desire.</p>\n</blockquote>\n<p>Once back into the container’s CLI, simply type <code>exit</code> to logout and return back to the host’s terminal.</p>\n<p>Once the <code>index.html</code> is updated, refresh your browser or navigate back to <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\"><code>http://localhost:10000</code></a> to observer changes to your site.</p>\n<h3>Review</h3>\n<p>This concludes how to run a container with <code>docker run</code> command, how to attach to a container’s terminal via the <code>docker exec -it</code> command, and how to manipulate data within a running container.</p>\n <img src=\"/docker-101-mod1/docker-run.gif\" title=\"Running Docker Container\">","site":{"data":{}},"hexoIncludeMarkdown":{"markdown":[]},"excerpt":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Module 1: Running Docker Containers</h1>\n\n<p>Once you have Docker installed locally, you can verify your installation by simply typing</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker --version</span><br></pre></td></tr></table></figure>\n<p>to see an output similar to:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Docker version 17.06.0-ce, build 02c1d87</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>If you get a permissions errors on your local docker machine, type <code>sudo docker --version</code> to complete the task. The current user must be in <a href=\"https://docs.docker.com/engine/installation/linux/linux-postinstall/\" target=\"_blank\" rel=\"noopener\">sudoers or docker group</a> to execute docker commands.</p>\n</blockquote>","more":"<h2>Docker Images</h2>\n<p>All Docker containers are based off <a href=\"https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/\" target=\"_blank\" rel=\"noopener\">Docker images</a>. Docker images are built up from a series of layers. Each layer represents an instruction or resulting block storage changes to the container’s filesystem. Each layer except the very last one is read-only, so once an image is made, any changes to data in a running container are made on a separate R/W layer. Think of it as application layering where the first image layer is always a blank minimalistic starting block from <a href=\"https://hub.docker.com/_/scratch/\" target=\"_blank\" rel=\"noopener\">scratch</a> and changes are done by installing dependencies or applications that you desire to package with your docker image. See the visual below to illustrate the concept of image layering:</p>\n  \n<p>You can store docker images in several places:</p>\n<ul>\n<li><a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">1. Docker Hub</a></li>\n<li><a href=\"https://quay.io/tour/\" target=\"_blank\" rel=\"noopener\">2. Other Public Repositories</a></li>\n<li><a href=\"http://blog.thoward37.me/articles/where-are-docker-images-stored/\" target=\"_blank\" rel=\"noopener\">3. Locally on your machine</a></li>\n<li><a href=\"https://docs.docker.com/registry/deploying/#storage-customization\" target=\"_blank\" rel=\"noopener\">4. Private Docker registries</a></li>\n<li><a href=\"https://docs.docker.com/engine/reference/commandline/save/\" target=\"_blank\" rel=\"noopener\">5. In a tar archive</a></li>\n</ul>\n<p>In this tutorial we will mainly be concerning ourselves with <strong>#1</strong> where we are pulling images from Docker Hub.</p>\n<hr>\n<h2>Exercise 1 : Pulling Docker Images</h2>\n<p>Before any container is run, a copy of the docker image is always stored locally on the host. In this exercise we will pull a docker image from docker hub onto the docker host.</p>\n<h3>Step 1 : Pull an Image from Docker Hub</h3>\n<p>To pull an image down locally onto a host, run the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull mayankt/webserver:a</span><br></pre></td></tr></table></figure>\n<p>Here is a break down of the command as follows:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th></th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker pull</code></td>\n<td></td>\n<td>This docker command that tells docker engine to pull an image down from somewhere</td>\n</tr>\n<tr>\n<td><code>mayankt/webserver:a</code></td>\n<td></td>\n<td>This is the image name. By default, if a full FQDN is not specified, it is assumed you are pulling the image from docker hub. In this case, you will be pulling an image from my repository <a href=\"https://hub.docker.com/r/mayankt/webserver/\" target=\"_blank\" rel=\"noopener\">mayankt</a> with an image titled <code>webserver</code> with the tag of <code>a</code>. <a href=\"https://www.techrepublic.com/article/how-to-use-docker-tags-to-add-version-control-to-images/\" target=\"_blank\" rel=\"noopener\">Tagging</a> images can help with versioning of your docker images and many other CI/CD use cases as well.</td>\n</tr>\n</tbody>\n</table>\n<p>Once you run the command you should see an output similar to this:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pulling from mayankt/webserver</span><br><span class=\"line\">3ac0c2aa6889: Pull complete </span><br><span class=\"line\">ec2ec713dc4f: Pull complete </span><br><span class=\"line\">ea0a5af9851c: Pull complete </span><br><span class=\"line\">555bf6439b47: Pull complete </span><br><span class=\"line\">71080d75d6eb: Pull complete </span><br><span class=\"line\">c787ac6d0b0a: Pull complete </span><br><span class=\"line\">1a9841bc3a47: Pull complete </span><br><span class=\"line\">1a7ce5d6010a: Pull complete </span><br><span class=\"line\">eec46f0642a8: Pull complete </span><br><span class=\"line\">d2d3a856c0da: Pull complete </span><br><span class=\"line\">f128b2a739b4: Pull complete </span><br><span class=\"line\">1341f98ff817: Pull complete</span><br></pre></td></tr></table></figure>\n<p>Which indicates that the image is being pulled from docker hub locally onto your docker host.</p>\n<h3>Step 2 : List Local Docker Images</h3>\n<p>Type the following command to see a list of all images stored locally on your host.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>Your output should resemble :</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">mayankt/webserver   a                   18f05d0cd921        2 months ago        27.9MB</span><br></pre></td></tr></table></figure>\n<p>This output shows a 27.9 MB large docker image stored locally that can be run into instances of docker containers. All the <code>f128b2a739b4: Pull complete</code> outputs from the <code>docker pull</code> command above are the layers being pulled from Docker Hub of which constitute the <code>mayankt/webserver:a</code> docker image.</p>\n<h3>Review</h3>\n<p>A simple <code>docker pull &lt; image-name &gt;</code> commands shows how you can pull a docker image from the cloud directly. It’s not used until you run a container with it which we will do in the <a href=\"../Exercise-2\">next Exercise</a>.</p>\n <img src=\"/docker-101-mod1/docker-pull.gif\" title=\"Docker pull from Docker Hub\">\n<hr>\n<h2>Exercise 2 : Running a Docker Container</h2>\n<p>Lets convert a docker image into a running instance of a docker container to host a simple website.</p>\n<h3>Step 1 : Run a Docker Container</h3>\n<p>We will issue <a href=\"https://docs.docker.com/engine/reference/run/\" target=\"_blank\" rel=\"noopener\"><code>docker run</code></a> commands to run containers. Type the following command to host a website on the docker host on port <code>10000</code>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --restart=always --name=cpx-blog -p 10000:80 mayankt/cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the command from above:</p>\n<p>Command | | Details<br>\n— | | —<br>\n<code>docker run -dt</code> | | This will run the container detached in the background. Later we will see <a href=\"https://stackoverflow.com/questions/30172605/how-to-get-into-a-docker-container\" target=\"_blank\" rel=\"noopener\">how we can attach to this container’s terminal</a>, but for now we will have the container running detached in the background as a daemon.<br>\n<code>--restart=always</code> | | This will restart the container automatically if it crashes or if and when docker/host restart.<br>\n<code>--name=cpx-blog</code> | | This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container.<br>\n<code>-p 10000:80</code> | | This will expose port <code>10000</code> on the host and map it to port <code>80</code> on the container for access to the hosted website.<br>\n<code>mayankt/cpx-blog</code> | | This identifies the <code>latest</code> tagged image by default because no explicit tag is specified. It will be pulled from dockerhub to use when running the container. <strong>Note:</strong> It is not necessary to pull a desired image before executing a <code>docker run</code> command. If the image does not exist locally, it will be automatically pulled from the designated registry (Docker Hub in our case).</p>\n<p>Once you have entered the command, you will notice an output similar to below:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Unable to find image <span class=\"string\">'mayankt/cpx-blog:latest'</span> locally</span><br><span class=\"line\">latest: Pulling from mayankt/cpx-blog</span><br><span class=\"line\">3ac0c2aa6889: Already exists</span><br><span class=\"line\">ec2ec713dc4f: Already exists</span><br><span class=\"line\">ea0a5af9851c: Already exists</span><br><span class=\"line\">555bf6439b47: Already exists</span><br><span class=\"line\">71080d75d6eb: Already exists</span><br><span class=\"line\">c787ac6d0b0a: Already exists</span><br><span class=\"line\">1a9841bc3a47: Already exists</span><br><span class=\"line\">336c032aec9b: Pull complete</span><br><span class=\"line\">bc3b4209c6c5: Pull complete</span><br><span class=\"line\">3a5d33d6e1e0: Pull complete</span><br><span class=\"line\">7e846adb4c7d: Pull complete</span><br><span class=\"line\">Digest: sha256:141100857249a391261edf7335ffea1ca20478a15d3ac08c821561e7a8998ef9</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> mayankt/cpx-blog:latest</span><br><span class=\"line\">222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Notice some of the layers already exist locally from our previous webserver-a pull because both images use mutual base images that can be recycled and save on local space. Only deltas or layers that make cpx-blog unique from webserver-a are pulled that are not stored locally. Also the output provided in the last line <code>222bcc5747008a5c05f79d3a717f9132c8aa66234939677d3ebbcc5d883b5b5c</code> is the long unique id of the running container that can be referenced in future docker commands alternative to <code>cpx-blog</code>.</p>\n</blockquote>\n<h3>Step 2 : List all Running Containers</h3>\n<p>To see all of your running containers type the following command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps</span><br></pre></td></tr></table></figure>\n<p>That will yield an output similar to below.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS              PORTS                            NAMES</span><br><span class=\"line\">222bcc574700        mayankt/cpx-blog    <span class=\"string\">\"/bin/sh -c 'nginx'\"</span>   About a minute ago   Up About a minute   443/tcp, 0.0.0.0:10000-&gt;80/tcp   cpx-blog</span><br></pre></td></tr></table></figure>\n<p>This shows that the container named cpx-blog is running based on the image mayankt/cpx-blog with an external 10000 port exposed on the local host for remote access. Navigate to <a href=\"http://localhost:1000\" target=\"_blank\" rel=\"noopener\"><code>htt://localhost:10000</code></a> to see the website.</p>\n<p>To stop your running container, type the following command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Now to see all of your running and <strong>non running</strong> containers, type the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker ps -a</span><br></pre></td></tr></table></figure>\n<p>That will yield an output similar to below.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE                 COMMAND                CREATED             STATUS                       PORTS               NAMES</span><br><span class=\"line\">f407d06318f0        mayankt/cpx-blog   <span class=\"string\">\"/bin/sh -c 'nginx'\"</span>   10 minutes ago      Exited (137) 3 seconds ago                       cpx-blog</span><br></pre></td></tr></table></figure>\n<h3>Step 3 : Enter Container’s Shell</h3>\n<p>If you container is not running already, start the container with the following command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker start cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Then type the following command to enter the terminal shell of the container:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it cpx-blog /bin/sh</span><br></pre></td></tr></table></figure>\n<p>The breakdown of the command as follows:</p>\n<p>Command | | Details<br>\n— | | —<br>\n<code>docker exec -it</code> | | This will execute a command on the container with an interactive terminal (<code>-it</code>). We could execute commands in the background with a <code>-dt</code> if we wanted to, but we wouldn’t see the outcome and the command we’re running in this example is invoking a shell. If we wanted to run a script and not interact with it, we could have used the <code>-dt</code> flag.<br>\n<code>cpx-blog</code> | | This denotes to which running container to execute the command against. In our case, it’s the cpx-blog container.<br>\n<code>/bin/sh</code> | | This is the command itself that we want to execute in the container. In this example we are invoking the shell for terminal access into our container. In other examples we could execute specific scripts or bash files as well (i.e. <code>/var/scripts/init-db.sh</code> or any other file locally stored within the container).</p>\n<p>After executing the command, you should have entered into the shell prompt of the container itself. Lets manipulate some files inside the container and see them reflected onto the website.</p>\n<p>Within the container shell, enter the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /var/wwww/index.html</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>vi</code> invokes a CLI text editor. It is functionally the same thing as notepad or sublime text, but geared for CLI interfaces not GUI interfaces. <code>vi</code> utility helps edit files in the terminal.</p>\n</blockquote>\n<p>Once you have opened the <code>index.html</code> file, scroll down and change the text between :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;NetScaler NITRO Blogs&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<p>…to anything you desire, such as :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;LEARN DOCKER!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Edit text by entering the <code>i</code> key and then navigating the cursor to delete text you want to remove then typing in text you want to replace it with. Once completed, hit the <code>esc</code> key then <code>shift</code> + <code>:</code> key. Type <code>wq</code> to write and quit. You can then hit <code>ctrl</code> + <code>l</code> to clear the screen if you desire.</p>\n</blockquote>\n<p>Once back into the container’s CLI, simply type <code>exit</code> to logout and return back to the host’s terminal.</p>\n<p>Once the <code>index.html</code> is updated, refresh your browser or navigate back to <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\"><code>http://localhost:10000</code></a> to observer changes to your site.</p>\n<h3>Review</h3>\n<p>This concludes how to run a container with <code>docker run</code> command, how to attach to a container’s terminal via the <code>docker exec -it</code> command, and how to manipulate data within a running container.</p>\n <img src=\"/docker-101-mod1/docker-run.gif\" title=\"Running Docker Container\">"},{"title":"Introduction to Docker Files","date":"2017-12-15T01:28:29.000Z","show":false,"_content":"\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n# Module 2: Create an Image via Dockerfiles\n\nGiven that all Docker containers are based off specific [Docker images](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/), in this module we will explore one of many ways to create Docker Images that define your custom docker containers. The following list a few ways to create customer images docker images:\n\n1. [Save a running container into an image](https://docs.docker.com/engine/reference/commandline/save/)\n\n    * In this method, users initially run a docker container based on a desired base image. Then after changes are made by `docker exec -it` or other means on the running container, the live container is ultimately saved into a `.tar` archive in its desired state that can be later [loaded](https://docs.docker.com/engine/reference/commandline/load/) to run multiple new instances of the custom image.\n\n<!-- more --> \n2. Defining a [Dockerfile](https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images)\n\n    * This method is the most robust and more commonly use method to define and create docker images. A Dockerfile is essentially a recipe of commands to execute on a defined base image that constitute the desired state of a custom docker image. Consider the traditional workflow to configure a webserver which requires executing of scripts, updating local packages, pulling of code from various repositories, installing dependencies, etc. before the webserver is in its desired state. A Dockerfile can define those steps towards a desired state thus allowing changes to be made independently on external packages, code repositories, etc. and the Dockerfile will simply execute those commands and operations when you desire to build your custom container image.\n\n## Dockerfiles\n\nThe advantage of a Dockerfile over just storing the binary image (or a snapshot/template in other virtualization systems) is that the automatic builds will ensure you have the latest version of code, packages, and external resources available in your docker container. This is a good thing from a security perspective, as you want to ensure you’re not installing any vulnerable software. This is also a good thing from an operational perspective because it allows you to rapidly build out isolated environments based on defined recipe that can pull from external resources like git to compile and build microservices.\n\nBelow is an example of a simple <a href=\"/_code/docker-101/Dockerfile\" download=\"Dockerfile\">Dockerfile</a>   \n\n\n```\nFROM fnichol/uhttpd\nMAINTAINER Mayank Tahilramani and Brian Tannous\nCOPY ./cpx-blog /www\nEXPOSE 80\nENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\nCMD [\"\"]\n```\nBreakdown of details below:\n\n```\nFROM fnichol/uhttpd\n```\n\nThis denotes the base image to use. In this case, it's an image from Docker Hub of user [`fnichol`](https://github.com/fnichol/docker-uhttpd) who has already made a bare bone minimalistic docker image with the service [httpd](https://httpd.apache.org/docs/2.4/programs/httpd.html) pre-installed which allows us to hosts websites. All we have to do is provide our HTML code and relevant data. From this image, we will make changes and define our custom image based on subsequent commands in our Dockerfile.\n\n```\nMAINTAINER Mayank Tahilramani and Brian Tannous\n```\n\n This is just meta data for the image on who the maintainer/creator of the image and Dockerfile are.\n\n```\nCOPY ./cpx-blog /www\n```\n\nThis command simply copies everything `cpx-blog` directory that is local to the Dockerfile into the `/www` directory that is local to the container. Within the container there must already be a `/www` directory (as specified by the [base image](https://github.com/fnichol/docker-uhttpd) to put content in. In this case, any html code or data that will be served by httpd must reside in the `/www` directory within the container.\n\n```\nEXPOSE 80\n```\n\nThis command simply states that port 80 will be open on the container as expected to host a website.\n\n```\nENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\n```\n\nThis command dictates what to execute when the container starts. Note that the container's lifespan is directly dependent on the service it runs on start, in our case the httpd (found at `/usr/sbin/run_uhttpd`) is executed. The entrypoint script basically starts the webservice `httpd` hosting content in `/www`. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop running as well.\n\n```\nCMD [\"\"]\n```\n\nThis command is similar to `ENTRYPOINT` where traditionally you would define the default command to execute when the container starts. In this case, our ENTRYPOINT script is handling that for us so CMD can be left empty.\n   * `CMD` is a mandatory declaration in a Dockerfile.\n   * Check out this resource to learn more about difference in use cases between [`CMD` vs `ENTERYPOINT`](https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/)\n\n---\n\n## Exercise 1 : Write a Dockerfile\n\nIn this exercise we will create a new docker image locally from a Dockerfile as discussed in [Module 2](../) overview. We will also make edits to the Dockerfile to customize the image to our preference.\n\n### Step 1 : Clone Git Repository\n\nIn the `/data` directory on your host, clone the following git repository:\n\n```bash\n# Change the working directory to /data on the docker host\ncd /data\n\n# Clone a copy of the github project locally\nsudo git clone https://github.com/Citrix-TechSpecialist/GoLang-cpx.git\n\n# List the contents in the /data directory to see the GoLang-cpx project directory\nls -l\n```\n\nin the `/GoLang-cpx` directory there is a `Dockerfile`. Lets view the contents with the `cat` command.\n\n```\n# Change working directory into the GoLang-cpx project\ncd GoLang-cpx\n\n# View what all is in the GoLang-cpx directory\nls -l\n\n# View the Dockerfile contents\ncat Dockerfile\n```\n\nOnce you `cat` the file, you will notice the following content in the [Dockerfile](_code/docker-101/Dockerfile):\n\n```\nFROM fnichol/uhttpd\nMAINTAINER Mayank Tahilramani and Brian Tannous\nCOPY ./cpx-blog /www\nEXPOSE 80\nENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\nCMD [\"\"]\n```\nThe content above is pretty much the same we observed in the [Module-2](../) overview. We will now build this container using the [`docker build`](https://docs.docker.com/engine/reference/commandline/build/) command.\n\n### Step 2 : Build Docker Image\n\nType the following command to build your docker image:\n\n```bash\ndocker build -t cpx-blog .\n```\n\nHere is the breakdown of the command above:\n\nCommand | Details\n--- | ---\n`docker build` | This basically tells the docker engine to build an image.\n`-t` | This gives the image a name and optionally a tag in the `name:tag` format.\n`cpx-blog` | This will be the name of the created docker image.\n`.` | tells docker engine to look for a file named *Dockerfile* (by default) in the current directory.\n\n> Optionally if you named your `Dockerfile` something different like `sandbox.dockerfile` you can append the `-f sandbox.dockerfile` flag after `build` statement.\n\nYou will see the following output:\n\n```bash\nSending build context to Docker daemon  1.773MB\nStep 1/6 : FROM fnichol/uhttpd\nlatest: Pulling from fnichol/uhttpd\na3ed95caeb02: Pull complete\n1775fca35fb6: Pull complete\n718e21306e6b: Pull complete\n889bfeab2d4e: Pull complete\n8ac43f1732b7: Pull complete\ncefd08b5f834: Pull complete\na32be2ed7953: Pull complete\n1c78be7a5ec7: Pull complete\n74984e6e6d1c: Pull complete\nDigest: sha256:28e6f95cf33ae1336525034e2b9d58ddf3cc63a2cdd9edebc8765321d96da9e0\nStatus: Downloaded newer image for fnichol/uhttpd:latest\n ---> df0db1779d4d\nStep 2/6 : MAINTAINER Mayank Tahilramani and Brian Tannous\n ---> Running in 459db6d6a053\n ---> d51effaba5ae\nRemoving intermediate container 459db6d6a053\nStep 3/6 : COPY ./cpx-blog /www\n ---> b1510a20020d\nRemoving intermediate container b075c62a629b\nStep 4/6 : EXPOSE 80\n ---> Running in 84f5263cb817\n ---> f1f4672c9d5b\nRemoving intermediate container 84f5263cb817\nStep 5/6 : ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\n ---> Running in 8e2b276c3aa9\n ---> 552dfe1be7a7\nRemoving intermediate container 8e2b276c3aa9\nStep 6/6 : CMD\n ---> Running in 7c5da4990bea\n ---> 0c78968bbe81\nRemoving intermediate container 7c5da4990bea\nSuccessfully built 0c78968bbe81\nSuccessfully tagged cpx-blog:latest\n```\n\nYou can also see the images on the local host with the following command:\n\n```\ndocker images\n```\n\n...which shows:\n\n```bash\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncpx-blog            latest              0c78968bbe81        46 seconds ago      5.66MB\nfnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB\n```\nDocker pulled the base image `fnichol/uhttpd` from Docker Hub as well as created the layer on top with the changes we added defined in our Dockerfile to create the `cpx-blog` image. This concludes the creation of the image. Next we will create *ONE* more image that is an updated version of the `cpx-blog` image before we run our containers in [Exercise-2](../Exercise-2).\n\n### Step 3 : Tag a New Docker Image\n\nLets make updates to our `Dockerfile` in `/data/GoLang-cpx`. Open the file up in `nano` with the following command. `nano` is nothing more than a simple text editor for CLI. It can be considered an equivalent to [Sublime Text](https://www.sublimetext.com/) or [Notepad++](https://notepad-plus-plus.org/).\n\n```bash\n# In the /data/GoLang-cpx directory enter the following command:\nsudo nano Dockerfile\n```\n\nUpdate the file with your cursor and keyboard to reflect the following:\n\n```\nFROM fnichol/uhttpd\nMAINTAINER Mayank Tahilramani and Brian Tannous\nCOPY ./cpx-blog /www\nWORKDIR /www\nRUN echo \"find /www -type f -exec sed -i \\\"s/All rights reserved./Hosted by container: ${HOSTNAME}/g\\\" {} \\\\;\" > /tmp/update.sh && chmod +x /tmp/update.sh\nEXPOSE 80\nENTRYPOINT /tmp/update.sh && /usr/sbin/run_uhttpd -f -p 80 -h /www\nCMD [\"\"]\n```\n    >To exit `nano` after you are done editing, enter the keys `ctrl` + `x` then `y` and `enter` to save and quit.\n\nHere are the details on the updated command lines added above:\n\n```\nWORKDIR /www\n```\n\n  This changes the working directory of the docker build engine when executing `RUN` commands in the next line. Note that you cannot simply change directories by a single `RUN` command for example `cd /www` because each time you execute a `RUN` command, docker spawns a new container and therefore the default working directory become `/`. See more context [here](https://stackoverflow.com/questions/17891981/docker-run-cd-does-not-work-as-expected)\n\n\n```\nRUN echo \"find /www -type f -exec sed -i \\\"s/All rights reserved./Hosted by container: ${HOSTNAME}/g\\\" {} \\\\;\" > /tmp/update.sh && chmod +x /tmp/update.sh\n```\n  This command simply creates a script `/tmp/update.sh` which finds all files in the `/www` directory and replaces strings in them which match the pattern \"*All rights reserved.*\" with the string \"*Hosted by container: ${HOSTNAME}*\" where `${HOSTNAME}` is a built in environmental variable in the running container that holds the container's unique host name. By default the hostname of any container is it's short uuid. This script will essentially replace the footer of all web pages which state \"All rights reserved\" with which container is specifically hosting the website.\n\n   >Note that this command creates a script `/tmp/update.sh` but does not execute it. This command needs to be executed in a final running container state, not during an intermediate step when building the final image. Hence this script created here is executed in the `ENTRYPOINT` step below.\n\n```\nENTRYPOINT /tmp/update.sh && /usr/sbin/run_uhttpd -f -p 80 -h /www\n```\n This command dictates what to execute when the container starts. Note that the [container's lifespan](https://medium.com/@lherrera/life-and-death-of-a-container-146dfc62f808) is directly dependent on the service it runs on start, in our case first the `/tmp/update.sh` script executes to update footers on all html pages, then the httpd (found at `/usr/sbin/run_uhttpd`) is executed. The entrypoint script basically starts the webservice hosting content in `/www`. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop as well.\n\nWith the updated changes in our Dockerfile, we have introduced a new script into the container `/tmp/update.sh` which updated some HTML text on our website and is executed upon running the container as defined by our `ENTRYPOINT` statement.\n\nNow lets build our new image:\n\n```bash\n# In the /data/GoLang-cpx directory enter the following command:\ndocker build -t cpx-blog:v2 .\n```\n\nView your images via the `docker images` command to see a new tagged version of the `cpx-blog` image was created.\n\n```bash\nWORKDIR /www\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncpx-blog            v2                  7f4074f9eecf        9 seconds ago       5.66MB\ncpx-blog            latest              0c78968bbe81        25 minutes ago      5.66MB\nfnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB\n```\n### Review\n\nIn ***Step 1*** and ***Step 2*** we created 2 docker images of the same CPX-blog website. The first image was created using a Dockerfile form the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. The second image was created from a custom Dockerfile which added a script to update the footer of the website with the container's hostname. Below is a overview of the steps above.\n\n  {% asset_img docker-build.gif docker build %}\n\n---\n\n## Exercise 2 : Run a Docker Container\n\nIn this exercise we will create a two docker containers from two new images we created in the [previous exercise](../Exercise-1). We will also create a third container that uses volume mounts to share persistent data with the docker host. \n\n### Step 1 : `sudo docker run`\n\nLets run our first container based off the image we created from the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. Enter the following command to run your docker container: \n\n```\ndocker run -dt --name=cpx-blog-1 -p 10000:80 cpx-blog\n```\n \n Here is the breakdown of the command: \n\nCommand | | Details \n--- | --- | ---\n`docker run -dt` | | This will run the container detached with a terminal in the background. Later we will see how we can attach to this container's CLI, but for now we will have the container running detached in the background as a daemon. \n`--name=cpx-blog-1` | | This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container. \n`-p 10000:80` | |  This will expose port `10000` on the host and map it to port `80` on the container for access to the hosted website.\n`cpx-blog` | | This identifies the image we want to use by the docker engine to base our container off of. It will not bother pulling from Dockerhub because the image is already stored locally given you have completed [exercise 1](../Exercise-1).\n\nYou should receive an output of a long UID as a reference to the running container similar to `\ned2348b56eda197a90313c8876ab4e6601b52406ba1c6740ccccd6e996565f60`\n\nYou can view the running container by entering in the `docker ps` command: \n\n```\nCONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES\ned2348b56eda        cpx-blog            \"/bin/sh -c '/usr/...\"   About a minute ago   Up About a minute   0.0.0.0:10000->80/tcp   cpx-blog-1\n```\n\nNow lets view the website hosted by our docker container. If you are following along on your local machine, go to url [http://localhost:10000](http://localhost:10000).\n\nOn the website, scroll down to the very bottom to notice the footer of this page stating: `2016. All rights reserved.` Make a note of this, because we are now going to run our new container that will have updated footer information. \n\n  {% asset_img cpx-blog-1-footer.png cpx-blog-1 site's footer %}\n\nLastly, lets remove this container so we can recycle the host port `10000` for our new container. \n\n```\ndocker rm -f cpx-blog-1\n```\n\n### Step 2 : Run an Updated Container\n\nLets run our second container based off the image we created from the modified version of the Dockerfile in the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. Enter the following command to run your docker container: \n\n```\ndocker run -dt --name=cpx-blog-2 -p 10000:80 cpx-blog:v2\n```\n\nYou can view the running container by entering in the `docker ps` command: \n```\nCONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES\n6e115d1c21f5        cpx-blog:v2            \"/bin/sh -c '/usr/...\"   About a minute ago   Up About a minute   0.0.0.0:10000->80/tcp   cpx-blog-2\n```\n\nNow lets view the updated website hosted by our new docker container. If you are following along on your local machine, go to url [http://localhost:10000](http://localhost:10000).\n\nIf you are following along in the sandbox environment, navigate your local browser to [http://userX-lb.sl.americasreadiness.com](http://userX-lb.sl.americasreadiness.com) where `X` denotes your user number in the FQDN. \n\nOn the website, scroll down to the very bottom and notice the footer of this page stating: *2016. Hosted by container: **11ad31695df3**.* The container hostname is showing up because of the `/tmp/update.sh` script that was executed when the container was run to update all `.html` footer code as defined in our new Dockerfile.\n\n  {% asset_img cpx-blog-2-footer.png cpx-blog-2 site's footer %}\n \nLastly, lets remove this container so we can recycle the host port `10000` for our new container. \n\n```\ndocker rm -f cpx-blog-2\n```\n\n### Step 3 : Persistent Volume Mounts\n\nThus far we have seen the docker container host the website with the `.html` data local to it's file system. Ideally, you would not want to store any persistent data on the container itself, rather you should store in on some network or hyperconverged storage solution that the container can access as if local instead. This allow you to de-coupling storage of persistent data in the container from the compute processing done by the container itself and allows you to be more agile, spreads your failure domain, and scale independently in storage and compute capacity. \n\nIn this In this step, we will run the same container as in **step 1**, but with a volume mount that shares a directory with the docker host mounted in the container to share persistent data. Enter the following command to run a docker container with a [volume mount](https://docs.docker.com/engine/reference/run/#volume-shared-filesystems).\n\n```\ndocker run -dt --name=cpx-blog-3 -p 10000:80 -v /data/GoLang-cpx/cpx-blog:/www:rw cpx-blog\n```\n\nHere is the breakdown of the new volume mount `-v` flag in the `docker run` command: \n\nCommand | | Details\n--- |--- | ---\n`-v /data/GoLang-cpx/cpx-blog:/www:rw` | | The `-v` flag denotes that this container will have a volume mount that is located on the local host at `/data/GoLang-cpx/cpx-blog` and that directory will be mapped to the `/www` directory that is local to the container. The container will have *read/write* permissions to this directory as denoted by the `:rw` at the end. \n\n  * This flag allows us to remove the `COPY ./cpx-blog /www` command form our Dockerfile if desired to. However the pre-requisite of this container would become that a volume mount be provided at run time to host whatever content is in the mounted `/www` directory local to the container.. \n\n  * Adding volume mounts of persistent data to containers saves space as well, because now the data isn't replicated in each container, rather multiple containers can instead reference the same volume mount on a NFS network share, for example, mounted on the local docker host.\n\n  * Other services can also independently manipulate data in the volume mount directory on the host that have read-write access and it can be reflected in the running cpx-blog containers for example. \n\nOnce you have your container running, lets view the site hosted by our new docker container. If you are following along on your local machine, go to url [http://localhost:10000](http://localhost:10000).\n\nYou will notice that the site looks identical to it did in **Step 1**. Lets change some content to the title page to prove a point. \n\nEnter the following command to edit text in the `index.html` of the home page of the blog: \n\n```\nsudo nano /data/GoLang-cpx/cpx-blog/index.html\n```\n\nScroll down into the file where you see the line: \n\n```\n<h1 class=\"brand-title\">NetScaler NITRO Blogs</h1>\n```\n\nupdate that line to look like : \n\n```\n<h1 class=\"brand-title\">LEARN DOCKER!</h1>\n```\n\nSave and quit `nano` by entering the keys `ctrl` + `x` then `y` and `enter`. \n\nNow refresh your browser to the blog to view the updates changes. You should see a new title in the home page reflecting your changes to the `index.html`\n\nLastly, lets remove this container so we can recycle the host port `10000` for subsequent Modules. \n\n```\ndocker rm -f cpx-blog-3\n```\n\n### Review \n\nIn this module, we ran a container hosting our website using a Dockerfile in the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. We also ran a container that has a script that ran at runtime to dynamically update the footer on each webpage to display the container's hostname. Lastly, we deployed a third container that hosted the webpage through a volume mount where the data of the website only resided on the host and we showed that the data could be independently manipulated to reflect updates on our container hosted website. \n\nHere is an overview of the previous 3 steps. \n\n  {% asset_img docker-run-new.gif docker run 3 containers %}\n","source":"_posts/docker-101-mod2.md","raw":"---\ntitle: Introduction to Docker Files\ntag:\n - [docker]\n - [docker-cli]\n - [docker images]\n - [docker 101]\n - [dockerfile]\n - [storage]\n - [volume mount]\ncategory:\n  - [tutorials]\ndate: 2017-12-14 17:28:29\nshow: false\n---\n\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n# Module 2: Create an Image via Dockerfiles\n\nGiven that all Docker containers are based off specific [Docker images](https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/), in this module we will explore one of many ways to create Docker Images that define your custom docker containers. The following list a few ways to create customer images docker images:\n\n1. [Save a running container into an image](https://docs.docker.com/engine/reference/commandline/save/)\n\n    * In this method, users initially run a docker container based on a desired base image. Then after changes are made by `docker exec -it` or other means on the running container, the live container is ultimately saved into a `.tar` archive in its desired state that can be later [loaded](https://docs.docker.com/engine/reference/commandline/load/) to run multiple new instances of the custom image.\n\n<!-- more --> \n2. Defining a [Dockerfile](https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images)\n\n    * This method is the most robust and more commonly use method to define and create docker images. A Dockerfile is essentially a recipe of commands to execute on a defined base image that constitute the desired state of a custom docker image. Consider the traditional workflow to configure a webserver which requires executing of scripts, updating local packages, pulling of code from various repositories, installing dependencies, etc. before the webserver is in its desired state. A Dockerfile can define those steps towards a desired state thus allowing changes to be made independently on external packages, code repositories, etc. and the Dockerfile will simply execute those commands and operations when you desire to build your custom container image.\n\n## Dockerfiles\n\nThe advantage of a Dockerfile over just storing the binary image (or a snapshot/template in other virtualization systems) is that the automatic builds will ensure you have the latest version of code, packages, and external resources available in your docker container. This is a good thing from a security perspective, as you want to ensure you’re not installing any vulnerable software. This is also a good thing from an operational perspective because it allows you to rapidly build out isolated environments based on defined recipe that can pull from external resources like git to compile and build microservices.\n\nBelow is an example of a simple <a href=\"/_code/docker-101/Dockerfile\" download=\"Dockerfile\">Dockerfile</a>   \n\n\n```\nFROM fnichol/uhttpd\nMAINTAINER Mayank Tahilramani and Brian Tannous\nCOPY ./cpx-blog /www\nEXPOSE 80\nENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\nCMD [\"\"]\n```\nBreakdown of details below:\n\n```\nFROM fnichol/uhttpd\n```\n\nThis denotes the base image to use. In this case, it's an image from Docker Hub of user [`fnichol`](https://github.com/fnichol/docker-uhttpd) who has already made a bare bone minimalistic docker image with the service [httpd](https://httpd.apache.org/docs/2.4/programs/httpd.html) pre-installed which allows us to hosts websites. All we have to do is provide our HTML code and relevant data. From this image, we will make changes and define our custom image based on subsequent commands in our Dockerfile.\n\n```\nMAINTAINER Mayank Tahilramani and Brian Tannous\n```\n\n This is just meta data for the image on who the maintainer/creator of the image and Dockerfile are.\n\n```\nCOPY ./cpx-blog /www\n```\n\nThis command simply copies everything `cpx-blog` directory that is local to the Dockerfile into the `/www` directory that is local to the container. Within the container there must already be a `/www` directory (as specified by the [base image](https://github.com/fnichol/docker-uhttpd) to put content in. In this case, any html code or data that will be served by httpd must reside in the `/www` directory within the container.\n\n```\nEXPOSE 80\n```\n\nThis command simply states that port 80 will be open on the container as expected to host a website.\n\n```\nENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\n```\n\nThis command dictates what to execute when the container starts. Note that the container's lifespan is directly dependent on the service it runs on start, in our case the httpd (found at `/usr/sbin/run_uhttpd`) is executed. The entrypoint script basically starts the webservice `httpd` hosting content in `/www`. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop running as well.\n\n```\nCMD [\"\"]\n```\n\nThis command is similar to `ENTRYPOINT` where traditionally you would define the default command to execute when the container starts. In this case, our ENTRYPOINT script is handling that for us so CMD can be left empty.\n   * `CMD` is a mandatory declaration in a Dockerfile.\n   * Check out this resource to learn more about difference in use cases between [`CMD` vs `ENTERYPOINT`](https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/)\n\n---\n\n## Exercise 1 : Write a Dockerfile\n\nIn this exercise we will create a new docker image locally from a Dockerfile as discussed in [Module 2](../) overview. We will also make edits to the Dockerfile to customize the image to our preference.\n\n### Step 1 : Clone Git Repository\n\nIn the `/data` directory on your host, clone the following git repository:\n\n```bash\n# Change the working directory to /data on the docker host\ncd /data\n\n# Clone a copy of the github project locally\nsudo git clone https://github.com/Citrix-TechSpecialist/GoLang-cpx.git\n\n# List the contents in the /data directory to see the GoLang-cpx project directory\nls -l\n```\n\nin the `/GoLang-cpx` directory there is a `Dockerfile`. Lets view the contents with the `cat` command.\n\n```\n# Change working directory into the GoLang-cpx project\ncd GoLang-cpx\n\n# View what all is in the GoLang-cpx directory\nls -l\n\n# View the Dockerfile contents\ncat Dockerfile\n```\n\nOnce you `cat` the file, you will notice the following content in the [Dockerfile](_code/docker-101/Dockerfile):\n\n```\nFROM fnichol/uhttpd\nMAINTAINER Mayank Tahilramani and Brian Tannous\nCOPY ./cpx-blog /www\nEXPOSE 80\nENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\nCMD [\"\"]\n```\nThe content above is pretty much the same we observed in the [Module-2](../) overview. We will now build this container using the [`docker build`](https://docs.docker.com/engine/reference/commandline/build/) command.\n\n### Step 2 : Build Docker Image\n\nType the following command to build your docker image:\n\n```bash\ndocker build -t cpx-blog .\n```\n\nHere is the breakdown of the command above:\n\nCommand | Details\n--- | ---\n`docker build` | This basically tells the docker engine to build an image.\n`-t` | This gives the image a name and optionally a tag in the `name:tag` format.\n`cpx-blog` | This will be the name of the created docker image.\n`.` | tells docker engine to look for a file named *Dockerfile* (by default) in the current directory.\n\n> Optionally if you named your `Dockerfile` something different like `sandbox.dockerfile` you can append the `-f sandbox.dockerfile` flag after `build` statement.\n\nYou will see the following output:\n\n```bash\nSending build context to Docker daemon  1.773MB\nStep 1/6 : FROM fnichol/uhttpd\nlatest: Pulling from fnichol/uhttpd\na3ed95caeb02: Pull complete\n1775fca35fb6: Pull complete\n718e21306e6b: Pull complete\n889bfeab2d4e: Pull complete\n8ac43f1732b7: Pull complete\ncefd08b5f834: Pull complete\na32be2ed7953: Pull complete\n1c78be7a5ec7: Pull complete\n74984e6e6d1c: Pull complete\nDigest: sha256:28e6f95cf33ae1336525034e2b9d58ddf3cc63a2cdd9edebc8765321d96da9e0\nStatus: Downloaded newer image for fnichol/uhttpd:latest\n ---> df0db1779d4d\nStep 2/6 : MAINTAINER Mayank Tahilramani and Brian Tannous\n ---> Running in 459db6d6a053\n ---> d51effaba5ae\nRemoving intermediate container 459db6d6a053\nStep 3/6 : COPY ./cpx-blog /www\n ---> b1510a20020d\nRemoving intermediate container b075c62a629b\nStep 4/6 : EXPOSE 80\n ---> Running in 84f5263cb817\n ---> f1f4672c9d5b\nRemoving intermediate container 84f5263cb817\nStep 5/6 : ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www\n ---> Running in 8e2b276c3aa9\n ---> 552dfe1be7a7\nRemoving intermediate container 8e2b276c3aa9\nStep 6/6 : CMD\n ---> Running in 7c5da4990bea\n ---> 0c78968bbe81\nRemoving intermediate container 7c5da4990bea\nSuccessfully built 0c78968bbe81\nSuccessfully tagged cpx-blog:latest\n```\n\nYou can also see the images on the local host with the following command:\n\n```\ndocker images\n```\n\n...which shows:\n\n```bash\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncpx-blog            latest              0c78968bbe81        46 seconds ago      5.66MB\nfnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB\n```\nDocker pulled the base image `fnichol/uhttpd` from Docker Hub as well as created the layer on top with the changes we added defined in our Dockerfile to create the `cpx-blog` image. This concludes the creation of the image. Next we will create *ONE* more image that is an updated version of the `cpx-blog` image before we run our containers in [Exercise-2](../Exercise-2).\n\n### Step 3 : Tag a New Docker Image\n\nLets make updates to our `Dockerfile` in `/data/GoLang-cpx`. Open the file up in `nano` with the following command. `nano` is nothing more than a simple text editor for CLI. It can be considered an equivalent to [Sublime Text](https://www.sublimetext.com/) or [Notepad++](https://notepad-plus-plus.org/).\n\n```bash\n# In the /data/GoLang-cpx directory enter the following command:\nsudo nano Dockerfile\n```\n\nUpdate the file with your cursor and keyboard to reflect the following:\n\n```\nFROM fnichol/uhttpd\nMAINTAINER Mayank Tahilramani and Brian Tannous\nCOPY ./cpx-blog /www\nWORKDIR /www\nRUN echo \"find /www -type f -exec sed -i \\\"s/All rights reserved./Hosted by container: ${HOSTNAME}/g\\\" {} \\\\;\" > /tmp/update.sh && chmod +x /tmp/update.sh\nEXPOSE 80\nENTRYPOINT /tmp/update.sh && /usr/sbin/run_uhttpd -f -p 80 -h /www\nCMD [\"\"]\n```\n    >To exit `nano` after you are done editing, enter the keys `ctrl` + `x` then `y` and `enter` to save and quit.\n\nHere are the details on the updated command lines added above:\n\n```\nWORKDIR /www\n```\n\n  This changes the working directory of the docker build engine when executing `RUN` commands in the next line. Note that you cannot simply change directories by a single `RUN` command for example `cd /www` because each time you execute a `RUN` command, docker spawns a new container and therefore the default working directory become `/`. See more context [here](https://stackoverflow.com/questions/17891981/docker-run-cd-does-not-work-as-expected)\n\n\n```\nRUN echo \"find /www -type f -exec sed -i \\\"s/All rights reserved./Hosted by container: ${HOSTNAME}/g\\\" {} \\\\;\" > /tmp/update.sh && chmod +x /tmp/update.sh\n```\n  This command simply creates a script `/tmp/update.sh` which finds all files in the `/www` directory and replaces strings in them which match the pattern \"*All rights reserved.*\" with the string \"*Hosted by container: ${HOSTNAME}*\" where `${HOSTNAME}` is a built in environmental variable in the running container that holds the container's unique host name. By default the hostname of any container is it's short uuid. This script will essentially replace the footer of all web pages which state \"All rights reserved\" with which container is specifically hosting the website.\n\n   >Note that this command creates a script `/tmp/update.sh` but does not execute it. This command needs to be executed in a final running container state, not during an intermediate step when building the final image. Hence this script created here is executed in the `ENTRYPOINT` step below.\n\n```\nENTRYPOINT /tmp/update.sh && /usr/sbin/run_uhttpd -f -p 80 -h /www\n```\n This command dictates what to execute when the container starts. Note that the [container's lifespan](https://medium.com/@lherrera/life-and-death-of-a-container-146dfc62f808) is directly dependent on the service it runs on start, in our case first the `/tmp/update.sh` script executes to update footers on all html pages, then the httpd (found at `/usr/sbin/run_uhttpd`) is executed. The entrypoint script basically starts the webservice hosting content in `/www`. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop as well.\n\nWith the updated changes in our Dockerfile, we have introduced a new script into the container `/tmp/update.sh` which updated some HTML text on our website and is executed upon running the container as defined by our `ENTRYPOINT` statement.\n\nNow lets build our new image:\n\n```bash\n# In the /data/GoLang-cpx directory enter the following command:\ndocker build -t cpx-blog:v2 .\n```\n\nView your images via the `docker images` command to see a new tagged version of the `cpx-blog` image was created.\n\n```bash\nWORKDIR /www\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncpx-blog            v2                  7f4074f9eecf        9 seconds ago       5.66MB\ncpx-blog            latest              0c78968bbe81        25 minutes ago      5.66MB\nfnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB\n```\n### Review\n\nIn ***Step 1*** and ***Step 2*** we created 2 docker images of the same CPX-blog website. The first image was created using a Dockerfile form the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. The second image was created from a custom Dockerfile which added a script to update the footer of the website with the container's hostname. Below is a overview of the steps above.\n\n  {% asset_img docker-build.gif docker build %}\n\n---\n\n## Exercise 2 : Run a Docker Container\n\nIn this exercise we will create a two docker containers from two new images we created in the [previous exercise](../Exercise-1). We will also create a third container that uses volume mounts to share persistent data with the docker host. \n\n### Step 1 : `sudo docker run`\n\nLets run our first container based off the image we created from the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. Enter the following command to run your docker container: \n\n```\ndocker run -dt --name=cpx-blog-1 -p 10000:80 cpx-blog\n```\n \n Here is the breakdown of the command: \n\nCommand | | Details \n--- | --- | ---\n`docker run -dt` | | This will run the container detached with a terminal in the background. Later we will see how we can attach to this container's CLI, but for now we will have the container running detached in the background as a daemon. \n`--name=cpx-blog-1` | | This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container. \n`-p 10000:80` | |  This will expose port `10000` on the host and map it to port `80` on the container for access to the hosted website.\n`cpx-blog` | | This identifies the image we want to use by the docker engine to base our container off of. It will not bother pulling from Dockerhub because the image is already stored locally given you have completed [exercise 1](../Exercise-1).\n\nYou should receive an output of a long UID as a reference to the running container similar to `\ned2348b56eda197a90313c8876ab4e6601b52406ba1c6740ccccd6e996565f60`\n\nYou can view the running container by entering in the `docker ps` command: \n\n```\nCONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES\ned2348b56eda        cpx-blog            \"/bin/sh -c '/usr/...\"   About a minute ago   Up About a minute   0.0.0.0:10000->80/tcp   cpx-blog-1\n```\n\nNow lets view the website hosted by our docker container. If you are following along on your local machine, go to url [http://localhost:10000](http://localhost:10000).\n\nOn the website, scroll down to the very bottom to notice the footer of this page stating: `2016. All rights reserved.` Make a note of this, because we are now going to run our new container that will have updated footer information. \n\n  {% asset_img cpx-blog-1-footer.png cpx-blog-1 site's footer %}\n\nLastly, lets remove this container so we can recycle the host port `10000` for our new container. \n\n```\ndocker rm -f cpx-blog-1\n```\n\n### Step 2 : Run an Updated Container\n\nLets run our second container based off the image we created from the modified version of the Dockerfile in the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. Enter the following command to run your docker container: \n\n```\ndocker run -dt --name=cpx-blog-2 -p 10000:80 cpx-blog:v2\n```\n\nYou can view the running container by entering in the `docker ps` command: \n```\nCONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES\n6e115d1c21f5        cpx-blog:v2            \"/bin/sh -c '/usr/...\"   About a minute ago   Up About a minute   0.0.0.0:10000->80/tcp   cpx-blog-2\n```\n\nNow lets view the updated website hosted by our new docker container. If you are following along on your local machine, go to url [http://localhost:10000](http://localhost:10000).\n\nIf you are following along in the sandbox environment, navigate your local browser to [http://userX-lb.sl.americasreadiness.com](http://userX-lb.sl.americasreadiness.com) where `X` denotes your user number in the FQDN. \n\nOn the website, scroll down to the very bottom and notice the footer of this page stating: *2016. Hosted by container: **11ad31695df3**.* The container hostname is showing up because of the `/tmp/update.sh` script that was executed when the container was run to update all `.html` footer code as defined in our new Dockerfile.\n\n  {% asset_img cpx-blog-2-footer.png cpx-blog-2 site's footer %}\n \nLastly, lets remove this container so we can recycle the host port `10000` for our new container. \n\n```\ndocker rm -f cpx-blog-2\n```\n\n### Step 3 : Persistent Volume Mounts\n\nThus far we have seen the docker container host the website with the `.html` data local to it's file system. Ideally, you would not want to store any persistent data on the container itself, rather you should store in on some network or hyperconverged storage solution that the container can access as if local instead. This allow you to de-coupling storage of persistent data in the container from the compute processing done by the container itself and allows you to be more agile, spreads your failure domain, and scale independently in storage and compute capacity. \n\nIn this In this step, we will run the same container as in **step 1**, but with a volume mount that shares a directory with the docker host mounted in the container to share persistent data. Enter the following command to run a docker container with a [volume mount](https://docs.docker.com/engine/reference/run/#volume-shared-filesystems).\n\n```\ndocker run -dt --name=cpx-blog-3 -p 10000:80 -v /data/GoLang-cpx/cpx-blog:/www:rw cpx-blog\n```\n\nHere is the breakdown of the new volume mount `-v` flag in the `docker run` command: \n\nCommand | | Details\n--- |--- | ---\n`-v /data/GoLang-cpx/cpx-blog:/www:rw` | | The `-v` flag denotes that this container will have a volume mount that is located on the local host at `/data/GoLang-cpx/cpx-blog` and that directory will be mapped to the `/www` directory that is local to the container. The container will have *read/write* permissions to this directory as denoted by the `:rw` at the end. \n\n  * This flag allows us to remove the `COPY ./cpx-blog /www` command form our Dockerfile if desired to. However the pre-requisite of this container would become that a volume mount be provided at run time to host whatever content is in the mounted `/www` directory local to the container.. \n\n  * Adding volume mounts of persistent data to containers saves space as well, because now the data isn't replicated in each container, rather multiple containers can instead reference the same volume mount on a NFS network share, for example, mounted on the local docker host.\n\n  * Other services can also independently manipulate data in the volume mount directory on the host that have read-write access and it can be reflected in the running cpx-blog containers for example. \n\nOnce you have your container running, lets view the site hosted by our new docker container. If you are following along on your local machine, go to url [http://localhost:10000](http://localhost:10000).\n\nYou will notice that the site looks identical to it did in **Step 1**. Lets change some content to the title page to prove a point. \n\nEnter the following command to edit text in the `index.html` of the home page of the blog: \n\n```\nsudo nano /data/GoLang-cpx/cpx-blog/index.html\n```\n\nScroll down into the file where you see the line: \n\n```\n<h1 class=\"brand-title\">NetScaler NITRO Blogs</h1>\n```\n\nupdate that line to look like : \n\n```\n<h1 class=\"brand-title\">LEARN DOCKER!</h1>\n```\n\nSave and quit `nano` by entering the keys `ctrl` + `x` then `y` and `enter`. \n\nNow refresh your browser to the blog to view the updates changes. You should see a new title in the home page reflecting your changes to the `index.html`\n\nLastly, lets remove this container so we can recycle the host port `10000` for subsequent Modules. \n\n```\ndocker rm -f cpx-blog-3\n```\n\n### Review \n\nIn this module, we ran a container hosting our website using a Dockerfile in the [GoLang-cpx](https://github.com/Citrix-TechSpecialist/GoLang-cpx/) repository. We also ran a container that has a script that ran at runtime to dynamically update the footer on each webpage to display the container's hostname. Lastly, we deployed a third container that hosted the webpage through a volume mount where the data of the website only resided on the host and we showed that the data could be independently manipulated to reflect updates on our container hosted website. \n\nHere is an overview of the previous 3 steps. \n\n  {% asset_img docker-run-new.gif docker run 3 containers %}\n","slug":"docker-101-mod2","published":1,"updated":"2017-12-15T07:42:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb8926jl000bpbmlb6textz6","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Module 2: Create an Image via Dockerfiles</h1>\n<p>Given that all Docker containers are based off specific <a href=\"https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/\" target=\"_blank\" rel=\"noopener\">Docker images</a>, in this module we will explore one of many ways to create Docker Images that define your custom docker containers. The following list a few ways to create customer images docker images:</p>\n<ol>\n<li>\n<p><a href=\"https://docs.docker.com/engine/reference/commandline/save/\" target=\"_blank\" rel=\"noopener\">Save a running container into an image</a></p>\n<ul>\n<li>In this method, users initially run a docker container based on a desired base image. Then after changes are made by <code>docker exec -it</code> or other means on the running container, the live container is ultimately saved into a <code>.tar</code> archive in its desired state that can be later <a href=\"https://docs.docker.com/engine/reference/commandline/load/\" target=\"_blank\" rel=\"noopener\">loaded</a> to run multiple new instances of the custom image.</li>\n</ul>\n</li>\n</ol>\n<a id=\"more\"></a> \n<ol start=\"2\">\n<li>\n<p>Defining a <a href=\"https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images\" target=\"_blank\" rel=\"noopener\">Dockerfile</a></p>\n<ul>\n<li>This method is the most robust and more commonly use method to define and create docker images. A Dockerfile is essentially a recipe of commands to execute on a defined base image that constitute the desired state of a custom docker image. Consider the traditional workflow to configure a webserver which requires executing of scripts, updating local packages, pulling of code from various repositories, installing dependencies, etc. before the webserver is in its desired state. A Dockerfile can define those steps towards a desired state thus allowing changes to be made independently on external packages, code repositories, etc. and the Dockerfile will simply execute those commands and operations when you desire to build your custom container image.</li>\n</ul>\n</li>\n</ol>\n<h2>Dockerfiles</h2>\n<p>The advantage of a Dockerfile over just storing the binary image (or a snapshot/template in other virtualization systems) is that the automatic builds will ensure you have the latest version of code, packages, and external resources available in your docker container. This is a good thing from a security perspective, as you want to ensure you’re not installing any vulnerable software. This is also a good thing from an operational perspective because it allows you to rapidly build out isolated environments based on defined recipe that can pull from external resources like git to compile and build microservices.</p>\n<p>Below is an example of a simple <a href=\"/_code/docker-101/Dockerfile\" download=\"Dockerfile\">Dockerfile</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\">COPY ./cpx-blog /www</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\">ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>Breakdown of details below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br></pre></td></tr></table></figure>\n<p>This denotes the base image to use. In this case, it’s an image from Docker Hub of user <a href=\"https://github.com/fnichol/docker-uhttpd\" target=\"_blank\" rel=\"noopener\"><code>fnichol</code></a> who has already made a bare bone minimalistic docker image with the service <a href=\"https://httpd.apache.org/docs/2.4/programs/httpd.html\" target=\"_blank\" rel=\"noopener\">httpd</a> pre-installed which allows us to hosts websites. All we have to do is provide our HTML code and relevant data. From this image, we will make changes and define our custom image based on subsequent commands in our Dockerfile.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br></pre></td></tr></table></figure>\n<p>This is just meta data for the image on who the maintainer/creator of the image and Dockerfile are.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ./cpx-blog /www</span><br></pre></td></tr></table></figure>\n<p>This command simply copies everything <code>cpx-blog</code> directory that is local to the Dockerfile into the <code>/www</code> directory that is local to the container. Within the container there must already be a <code>/www</code> directory (as specified by the <a href=\"https://github.com/fnichol/docker-uhttpd\" target=\"_blank\" rel=\"noopener\">base image</a> to put content in. In this case, any html code or data that will be served by httpd must reside in the <code>/www</code> directory within the container.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE 80</span><br></pre></td></tr></table></figure>\n<p>This command simply states that port 80 will be open on the container as expected to host a website.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br></pre></td></tr></table></figure>\n<p>This command dictates what to execute when the container starts. Note that the container’s lifespan is directly dependent on the service it runs on start, in our case the httpd (found at <code>/usr/sbin/run_uhttpd</code>) is executed. The entrypoint script basically starts the webservice <code>httpd</code> hosting content in <code>/www</code>. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop running as well.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>This command is similar to <code>ENTRYPOINT</code> where traditionally you would define the default command to execute when the container starts. In this case, our ENTRYPOINT script is handling that for us so CMD can be left empty.</p>\n<ul>\n<li><code>CMD</code> is a mandatory declaration in a Dockerfile.</li>\n<li>Check out this resource to learn more about difference in use cases between <a href=\"https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/\" target=\"_blank\" rel=\"noopener\"><code>CMD</code> vs <code>ENTERYPOINT</code></a></li>\n</ul>\n<hr>\n<h2>Exercise 1 : Write a Dockerfile</h2>\n<p>In this exercise we will create a new docker image locally from a Dockerfile as discussed in <a href=\"../\">Module 2</a> overview. We will also make edits to the Dockerfile to customize the image to our preference.</p>\n<h3>Step 1 : Clone Git Repository</h3>\n<p>In the <code>/data</code> directory on your host, clone the following git repository:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Change the working directory to /data on the docker host</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clone a copy of the github project locally</span></span><br><span class=\"line\">sudo git <span class=\"built_in\">clone</span> https://github.com/Citrix-TechSpecialist/GoLang-cpx.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># List the contents in the /data directory to see the GoLang-cpx project directory</span></span><br><span class=\"line\">ls -l</span><br></pre></td></tr></table></figure>\n<p>in the <code>/GoLang-cpx</code> directory there is a <code>Dockerfile</code>. Lets view the contents with the <code>cat</code> command.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Change working directory into the GoLang-cpx project</span><br><span class=\"line\">cd GoLang-cpx</span><br><span class=\"line\"></span><br><span class=\"line\"># View what all is in the GoLang-cpx directory</span><br><span class=\"line\">ls -l</span><br><span class=\"line\"></span><br><span class=\"line\"># View the Dockerfile contents</span><br><span class=\"line\">cat Dockerfile</span><br></pre></td></tr></table></figure>\n<p>Once you <code>cat</code> the file, you will notice the following content in the <a href=\"_code/docker-101/Dockerfile\">Dockerfile</a>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\">COPY ./cpx-blog /www</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\">ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>The content above is pretty much the same we observed in the <a href=\"../\">Module-2</a> overview. We will now build this container using the <a href=\"https://docs.docker.com/engine/reference/commandline/build/\" target=\"_blank\" rel=\"noopener\"><code>docker build</code></a> command.</p>\n<h3>Step 2 : Build Docker Image</h3>\n<p>Type the following command to build your docker image:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t cpx-blog .</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the command above:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker build</code></td>\n<td>This basically tells the docker engine to build an image.</td>\n</tr>\n<tr>\n<td><code>-t</code></td>\n<td>This gives the image a name and optionally a tag in the <code>name:tag</code> format.</td>\n</tr>\n<tr>\n<td><code>cpx-blog</code></td>\n<td>This will be the name of the created docker image.</td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td>tells docker engine to look for a file named <em>Dockerfile</em> (by default) in the current directory.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Optionally if you named your <code>Dockerfile</code> something different like <code>sandbox.dockerfile</code> you can append the <code>-f sandbox.dockerfile</code> flag after <code>build</code> statement.</p>\n</blockquote>\n<p>You will see the following output:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sending build context to Docker daemon  1.773MB</span><br><span class=\"line\">Step 1/6 : FROM fnichol/uhttpd</span><br><span class=\"line\">latest: Pulling from fnichol/uhttpd</span><br><span class=\"line\">a3ed95caeb02: Pull complete</span><br><span class=\"line\">1775fca35fb6: Pull complete</span><br><span class=\"line\">718e21306e6b: Pull complete</span><br><span class=\"line\">889bfeab2d4e: Pull complete</span><br><span class=\"line\">8ac43f1732b7: Pull complete</span><br><span class=\"line\">cefd08b5f834: Pull complete</span><br><span class=\"line\">a32be2ed7953: Pull complete</span><br><span class=\"line\">1c78be7a5ec7: Pull complete</span><br><span class=\"line\">74984e6e6d1c: Pull complete</span><br><span class=\"line\">Digest: sha256:28e6f95cf33ae1336525034e2b9d58ddf3cc63a2cdd9edebc8765321d96da9e0</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> fnichol/uhttpd:latest</span><br><span class=\"line\"> ---&gt; df0db1779d4d</span><br><span class=\"line\">Step 2/6 : MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 459db6d6a053</span><br><span class=\"line\"> ---&gt; d51effaba5ae</span><br><span class=\"line\">Removing intermediate container 459db6d6a053</span><br><span class=\"line\">Step 3/6 : COPY ./cpx-blog /www</span><br><span class=\"line\"> ---&gt; b1510a20020d</span><br><span class=\"line\">Removing intermediate container b075c62a629b</span><br><span class=\"line\">Step 4/6 : EXPOSE 80</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 84f5263cb817</span><br><span class=\"line\"> ---&gt; f1f4672c9d5b</span><br><span class=\"line\">Removing intermediate container 84f5263cb817</span><br><span class=\"line\">Step 5/6 : ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 8e2b276c3aa9</span><br><span class=\"line\"> ---&gt; 552dfe1be7a7</span><br><span class=\"line\">Removing intermediate container 8e2b276c3aa9</span><br><span class=\"line\">Step 6/6 : CMD</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 7c5da4990bea</span><br><span class=\"line\"> ---&gt; 0c78968bbe81</span><br><span class=\"line\">Removing intermediate container 7c5da4990bea</span><br><span class=\"line\">Successfully built 0c78968bbe81</span><br><span class=\"line\">Successfully tagged cpx-blog:latest</span><br></pre></td></tr></table></figure>\n<p>You can also see the images on the local host with the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>…which shows:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">cpx-blog            latest              0c78968bbe81        46 seconds ago      5.66MB</span><br><span class=\"line\">fnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB</span><br></pre></td></tr></table></figure>\n<p>Docker pulled the base image <code>fnichol/uhttpd</code> from Docker Hub as well as created the layer on top with the changes we added defined in our Dockerfile to create the <code>cpx-blog</code> image. This concludes the creation of the image. Next we will create <em>ONE</em> more image that is an updated version of the <code>cpx-blog</code> image before we run our containers in <a href=\"../Exercise-2\">Exercise-2</a>.</p>\n<h3>Step 3 : Tag a New Docker Image</h3>\n<p>Lets make updates to our <code>Dockerfile</code> in <code>/data/GoLang-cpx</code>. Open the file up in <code>nano</code> with the following command. <code>nano</code> is nothing more than a simple text editor for CLI. It can be considered an equivalent to <a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"noopener\">Sublime Text</a> or <a href=\"https://notepad-plus-plus.org/\" target=\"_blank\" rel=\"noopener\">Notepad++</a>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># In the /data/GoLang-cpx directory enter the following command:</span></span><br><span class=\"line\">sudo nano Dockerfile</span><br></pre></td></tr></table></figure>\n<p>Update the file with your cursor and keyboard to reflect the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\">COPY ./cpx-blog /www</span><br><span class=\"line\">WORKDIR /www</span><br><span class=\"line\">RUN echo &quot;find /www -type f -exec sed -i \\&quot;s/All rights reserved./Hosted by container: $&#123;HOSTNAME&#125;/g\\&quot; &#123;&#125; \\\\;&quot; &gt; /tmp/update.sh &amp;&amp; chmod +x /tmp/update.sh</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\">ENTRYPOINT /tmp/update.sh &amp;&amp; /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<pre><code>&gt;To exit `nano` after you are done editing, enter the keys `ctrl` + `x` then `y` and `enter` to save and quit.\n</code></pre>\n<p>Here are the details on the updated command lines added above:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /www</span><br></pre></td></tr></table></figure>\n<p>This changes the working directory of the docker build engine when executing <code>RUN</code> commands in the next line. Note that you cannot simply change directories by a single <code>RUN</code> command for example <code>cd /www</code> because each time you execute a <code>RUN</code> command, docker spawns a new container and therefore the default working directory become <code>/</code>. See more context <a href=\"https://stackoverflow.com/questions/17891981/docker-run-cd-does-not-work-as-expected\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN echo &quot;find /www -type f -exec sed -i \\&quot;s/All rights reserved./Hosted by container: $&#123;HOSTNAME&#125;/g\\&quot; &#123;&#125; \\\\;&quot; &gt; /tmp/update.sh &amp;&amp; chmod +x /tmp/update.sh</span><br></pre></td></tr></table></figure>\n<p>This command simply creates a script <code>/tmp/update.sh</code> which finds all files in the <code>/www</code> directory and replaces strings in them which match the pattern “<em>All rights reserved.</em>” with the string “<em>Hosted by container: ${HOSTNAME}</em>” where <code>${HOSTNAME}</code> is a built in environmental variable in the running container that holds the container’s unique host name. By default the hostname of any container is it’s short uuid. This script will essentially replace the footer of all web pages which state “All rights reserved” with which container is specifically hosting the website.</p>\n<blockquote>\n<p>Note that this command creates a script <code>/tmp/update.sh</code> but does not execute it. This command needs to be executed in a final running container state, not during an intermediate step when building the final image. Hence this script created here is executed in the <code>ENTRYPOINT</code> step below.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT /tmp/update.sh &amp;&amp; /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br></pre></td></tr></table></figure>\n<p>This command dictates what to execute when the container starts. Note that the <a href=\"https://medium.com/@lherrera/life-and-death-of-a-container-146dfc62f808\" target=\"_blank\" rel=\"noopener\">container’s lifespan</a> is directly dependent on the service it runs on start, in our case first the <code>/tmp/update.sh</code> script executes to update footers on all html pages, then the httpd (found at <code>/usr/sbin/run_uhttpd</code>) is executed. The entrypoint script basically starts the webservice hosting content in <code>/www</code>. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop as well.</p>\n<p>With the updated changes in our Dockerfile, we have introduced a new script into the container <code>/tmp/update.sh</code> which updated some HTML text on our website and is executed upon running the container as defined by our <code>ENTRYPOINT</code> statement.</p>\n<p>Now lets build our new image:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># In the /data/GoLang-cpx directory enter the following command:</span></span><br><span class=\"line\">docker build -t cpx-blog:v2 .</span><br></pre></td></tr></table></figure>\n<p>View your images via the <code>docker images</code> command to see a new tagged version of the <code>cpx-blog</code> image was created.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /www</span><br><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">cpx-blog            v2                  7f4074f9eecf        9 seconds ago       5.66MB</span><br><span class=\"line\">cpx-blog            latest              0c78968bbe81        25 minutes ago      5.66MB</span><br><span class=\"line\">fnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB</span><br></pre></td></tr></table></figure>\n<h3>Review</h3>\n<p>In <strong><em>Step 1</em></strong> and <strong><em>Step 2</em></strong> we created 2 docker images of the same CPX-blog website. The first image was created using a Dockerfile form the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. The second image was created from a custom Dockerfile which added a script to update the footer of the website with the container’s hostname. Below is a overview of the steps above.</p>\n  <img src=\"/docker-101-mod2/docker-build.gif\" title=\"docker build\">\n<hr>\n<h2>Exercise 2 : Run a Docker Container</h2>\n<p>In this exercise we will create a two docker containers from two new images we created in the <a href=\"../Exercise-1\">previous exercise</a>. We will also create a third container that uses volume mounts to share persistent data with the docker host.</p>\n<h3>Step 1 : <code>sudo docker run</code></h3>\n<p>Lets run our first container based off the image we created from the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. Enter the following command to run your docker container:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --name=cpx-blog-1 -p 10000:80 cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the command:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th></th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker run -dt</code></td>\n<td></td>\n<td>This will run the container detached with a terminal in the background. Later we will see how we can attach to this container’s CLI, but for now we will have the container running detached in the background as a daemon.</td>\n</tr>\n<tr>\n<td><code>--name=cpx-blog-1</code></td>\n<td></td>\n<td>This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container.</td>\n</tr>\n<tr>\n<td><code>-p 10000:80</code></td>\n<td></td>\n<td>This will expose port <code>10000</code> on the host and map it to port <code>80</code> on the container for access to the hosted website.</td>\n</tr>\n<tr>\n<td><code>cpx-blog</code></td>\n<td></td>\n<td>This identifies the image we want to use by the docker engine to base our container off of. It will not bother pulling from Dockerhub because the image is already stored locally given you have completed <a href=\"../Exercise-1\">exercise 1</a>.</td>\n</tr>\n</tbody>\n</table>\n<p>You should receive an output of a long UID as a reference to the running container similar to <code>ed2348b56eda197a90313c8876ab4e6601b52406ba1c6740ccccd6e996565f60</code></p>\n<p>You can view the running container by entering in the <code>docker ps</code> command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES</span><br><span class=\"line\">ed2348b56eda        cpx-blog            &quot;/bin/sh -c &apos;/usr/...&quot;   About a minute ago   Up About a minute   0.0.0.0:10000-&gt;80/tcp   cpx-blog-1</span><br></pre></td></tr></table></figure>\n<p>Now lets view the website hosted by our docker container. If you are following along on your local machine, go to url <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<p>On the website, scroll down to the very bottom to notice the footer of this page stating: <code>2016. All rights reserved.</code> Make a note of this, because we are now going to run our new container that will have updated footer information.</p>\n  <img src=\"/docker-101-mod2/cpx-blog-1-footer.png\" title=\"cpx-blog-1 site\" alt=\"s footer\">\n<p>Lastly, lets remove this container so we can recycle the host port <code>10000</code> for our new container.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm -f cpx-blog-1</span><br></pre></td></tr></table></figure>\n<h3>Step 2 : Run an Updated Container</h3>\n<p>Lets run our second container based off the image we created from the modified version of the Dockerfile in the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. Enter the following command to run your docker container:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --name=cpx-blog-2 -p 10000:80 cpx-blog:v2</span><br></pre></td></tr></table></figure>\n<p>You can view the running container by entering in the <code>docker ps</code> command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES</span><br><span class=\"line\">6e115d1c21f5        cpx-blog:v2            &quot;/bin/sh -c &apos;/usr/...&quot;   About a minute ago   Up About a minute   0.0.0.0:10000-&gt;80/tcp   cpx-blog-2</span><br></pre></td></tr></table></figure>\n<p>Now lets view the updated website hosted by our new docker container. If you are following along on your local machine, go to url <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<p>If you are following along in the sandbox environment, navigate your local browser to <a href=\"http://userX-lb.sl.americasreadiness.com\" target=\"_blank\" rel=\"noopener\">http://userX-lb.sl.americasreadiness.com</a> where <code>X</code> denotes your user number in the FQDN.</p>\n<p>On the website, scroll down to the very bottom and notice the footer of this page stating: <em>2016. Hosted by container: <strong>11ad31695df3</strong>.</em> The container hostname is showing up because of the <code>/tmp/update.sh</code> script that was executed when the container was run to update all <code>.html</code> footer code as defined in our new Dockerfile.</p>\n  <img src=\"/docker-101-mod2/cpx-blog-2-footer.png\" title=\"cpx-blog-2 site\" alt=\"s footer\">\n<p>Lastly, lets remove this container so we can recycle the host port <code>10000</code> for our new container.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm -f cpx-blog-2</span><br></pre></td></tr></table></figure>\n<h3>Step 3 : Persistent Volume Mounts</h3>\n<p>Thus far we have seen the docker container host the website with the <code>.html</code> data local to it’s file system. Ideally, you would not want to store any persistent data on the container itself, rather you should store in on some network or hyperconverged storage solution that the container can access as if local instead. This allow you to de-coupling storage of persistent data in the container from the compute processing done by the container itself and allows you to be more agile, spreads your failure domain, and scale independently in storage and compute capacity.</p>\n<p>In this In this step, we will run the same container as in <strong>step 1</strong>, but with a volume mount that shares a directory with the docker host mounted in the container to share persistent data. Enter the following command to run a docker container with a <a href=\"https://docs.docker.com/engine/reference/run/#volume-shared-filesystems\" target=\"_blank\" rel=\"noopener\">volume mount</a>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --name=cpx-blog-3 -p 10000:80 -v /data/GoLang-cpx/cpx-blog:/www:rw cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the new volume mount <code>-v</code> flag in the <code>docker run</code> command:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th></th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-v /data/GoLang-cpx/cpx-blog:/www:rw</code></td>\n<td></td>\n<td>The <code>-v</code> flag denotes that this container will have a volume mount that is located on the local host at <code>/data/GoLang-cpx/cpx-blog</code> and that directory will be mapped to the <code>/www</code> directory that is local to the container. The container will have <em>read/write</em> permissions to this directory as denoted by the <code>:rw</code> at the end.</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>This flag allows us to remove the <code>COPY ./cpx-blog /www</code> command form our Dockerfile if desired to. However the pre-requisite of this container would become that a volume mount be provided at run time to host whatever content is in the mounted <code>/www</code> directory local to the container…</p>\n</li>\n<li>\n<p>Adding volume mounts of persistent data to containers saves space as well, because now the data isn’t replicated in each container, rather multiple containers can instead reference the same volume mount on a NFS network share, for example, mounted on the local docker host.</p>\n</li>\n<li>\n<p>Other services can also independently manipulate data in the volume mount directory on the host that have read-write access and it can be reflected in the running cpx-blog containers for example.</p>\n</li>\n</ul>\n<p>Once you have your container running, lets view the site hosted by our new docker container. If you are following along on your local machine, go to url <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<p>You will notice that the site looks identical to it did in <strong>Step 1</strong>. Lets change some content to the title page to prove a point.</p>\n<p>Enter the following command to edit text in the <code>index.html</code> of the home page of the blog:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /data/GoLang-cpx/cpx-blog/index.html</span><br></pre></td></tr></table></figure>\n<p>Scroll down into the file where you see the line:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;NetScaler NITRO Blogs&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<p>update that line to look like :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;LEARN DOCKER!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<p>Save and quit <code>nano</code> by entering the keys <code>ctrl</code> + <code>x</code> then <code>y</code> and <code>enter</code>.</p>\n<p>Now refresh your browser to the blog to view the updates changes. You should see a new title in the home page reflecting your changes to the <code>index.html</code></p>\n<p>Lastly, lets remove this container so we can recycle the host port <code>10000</code> for subsequent Modules.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm -f cpx-blog-3</span><br></pre></td></tr></table></figure>\n<h3>Review</h3>\n<p>In this module, we ran a container hosting our website using a Dockerfile in the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. We also ran a container that has a script that ran at runtime to dynamically update the footer on each webpage to display the container’s hostname. Lastly, we deployed a third container that hosted the webpage through a volume mount where the data of the website only resided on the host and we showed that the data could be independently manipulated to reflect updates on our container hosted website.</p>\n<p>Here is an overview of the previous 3 steps.</p>\n  <img src=\"/docker-101-mod2/docker-run-new.gif\" title=\"docker run 3 containers\">\n","site":{"data":{}},"hexoIncludeMarkdown":{"markdown":[]},"excerpt":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Module 2: Create an Image via Dockerfiles</h1>\n<p>Given that all Docker containers are based off specific <a href=\"https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/\" target=\"_blank\" rel=\"noopener\">Docker images</a>, in this module we will explore one of many ways to create Docker Images that define your custom docker containers. The following list a few ways to create customer images docker images:</p>\n<ol>\n<li>\n<p><a href=\"https://docs.docker.com/engine/reference/commandline/save/\" target=\"_blank\" rel=\"noopener\">Save a running container into an image</a></p>\n<ul>\n<li>In this method, users initially run a docker container based on a desired base image. Then after changes are made by <code>docker exec -it</code> or other means on the running container, the live container is ultimately saved into a <code>.tar</code> archive in its desired state that can be later <a href=\"https://docs.docker.com/engine/reference/commandline/load/\" target=\"_blank\" rel=\"noopener\">loaded</a> to run multiple new instances of the custom image.</li>\n</ul>\n</li>\n</ol>","more":"<ol start=\"2\">\n<li>\n<p>Defining a <a href=\"https://www.digitalocean.com/community/tutorials/docker-explained-using-dockerfiles-to-automate-building-of-images\" target=\"_blank\" rel=\"noopener\">Dockerfile</a></p>\n<ul>\n<li>This method is the most robust and more commonly use method to define and create docker images. A Dockerfile is essentially a recipe of commands to execute on a defined base image that constitute the desired state of a custom docker image. Consider the traditional workflow to configure a webserver which requires executing of scripts, updating local packages, pulling of code from various repositories, installing dependencies, etc. before the webserver is in its desired state. A Dockerfile can define those steps towards a desired state thus allowing changes to be made independently on external packages, code repositories, etc. and the Dockerfile will simply execute those commands and operations when you desire to build your custom container image.</li>\n</ul>\n</li>\n</ol>\n<h2>Dockerfiles</h2>\n<p>The advantage of a Dockerfile over just storing the binary image (or a snapshot/template in other virtualization systems) is that the automatic builds will ensure you have the latest version of code, packages, and external resources available in your docker container. This is a good thing from a security perspective, as you want to ensure you’re not installing any vulnerable software. This is also a good thing from an operational perspective because it allows you to rapidly build out isolated environments based on defined recipe that can pull from external resources like git to compile and build microservices.</p>\n<p>Below is an example of a simple <a href=\"/_code/docker-101/Dockerfile\" download=\"Dockerfile\">Dockerfile</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\">COPY ./cpx-blog /www</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\">ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>Breakdown of details below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br></pre></td></tr></table></figure>\n<p>This denotes the base image to use. In this case, it’s an image from Docker Hub of user <a href=\"https://github.com/fnichol/docker-uhttpd\" target=\"_blank\" rel=\"noopener\"><code>fnichol</code></a> who has already made a bare bone minimalistic docker image with the service <a href=\"https://httpd.apache.org/docs/2.4/programs/httpd.html\" target=\"_blank\" rel=\"noopener\">httpd</a> pre-installed which allows us to hosts websites. All we have to do is provide our HTML code and relevant data. From this image, we will make changes and define our custom image based on subsequent commands in our Dockerfile.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br></pre></td></tr></table></figure>\n<p>This is just meta data for the image on who the maintainer/creator of the image and Dockerfile are.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">COPY ./cpx-blog /www</span><br></pre></td></tr></table></figure>\n<p>This command simply copies everything <code>cpx-blog</code> directory that is local to the Dockerfile into the <code>/www</code> directory that is local to the container. Within the container there must already be a <code>/www</code> directory (as specified by the <a href=\"https://github.com/fnichol/docker-uhttpd\" target=\"_blank\" rel=\"noopener\">base image</a> to put content in. In this case, any html code or data that will be served by httpd must reside in the <code>/www</code> directory within the container.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXPOSE 80</span><br></pre></td></tr></table></figure>\n<p>This command simply states that port 80 will be open on the container as expected to host a website.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br></pre></td></tr></table></figure>\n<p>This command dictates what to execute when the container starts. Note that the container’s lifespan is directly dependent on the service it runs on start, in our case the httpd (found at <code>/usr/sbin/run_uhttpd</code>) is executed. The entrypoint script basically starts the webservice <code>httpd</code> hosting content in <code>/www</code>. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop running as well.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>This command is similar to <code>ENTRYPOINT</code> where traditionally you would define the default command to execute when the container starts. In this case, our ENTRYPOINT script is handling that for us so CMD can be left empty.</p>\n<ul>\n<li><code>CMD</code> is a mandatory declaration in a Dockerfile.</li>\n<li>Check out this resource to learn more about difference in use cases between <a href=\"https://www.ctl.io/developers/blog/post/dockerfile-entrypoint-vs-cmd/\" target=\"_blank\" rel=\"noopener\"><code>CMD</code> vs <code>ENTERYPOINT</code></a></li>\n</ul>\n<hr>\n<h2>Exercise 1 : Write a Dockerfile</h2>\n<p>In this exercise we will create a new docker image locally from a Dockerfile as discussed in <a href=\"../\">Module 2</a> overview. We will also make edits to the Dockerfile to customize the image to our preference.</p>\n<h3>Step 1 : Clone Git Repository</h3>\n<p>In the <code>/data</code> directory on your host, clone the following git repository:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Change the working directory to /data on the docker host</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clone a copy of the github project locally</span></span><br><span class=\"line\">sudo git <span class=\"built_in\">clone</span> https://github.com/Citrix-TechSpecialist/GoLang-cpx.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># List the contents in the /data directory to see the GoLang-cpx project directory</span></span><br><span class=\"line\">ls -l</span><br></pre></td></tr></table></figure>\n<p>in the <code>/GoLang-cpx</code> directory there is a <code>Dockerfile</code>. Lets view the contents with the <code>cat</code> command.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Change working directory into the GoLang-cpx project</span><br><span class=\"line\">cd GoLang-cpx</span><br><span class=\"line\"></span><br><span class=\"line\"># View what all is in the GoLang-cpx directory</span><br><span class=\"line\">ls -l</span><br><span class=\"line\"></span><br><span class=\"line\"># View the Dockerfile contents</span><br><span class=\"line\">cat Dockerfile</span><br></pre></td></tr></table></figure>\n<p>Once you <code>cat</code> the file, you will notice the following content in the <a href=\"_code/docker-101/Dockerfile\">Dockerfile</a>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\">COPY ./cpx-blog /www</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\">ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>The content above is pretty much the same we observed in the <a href=\"../\">Module-2</a> overview. We will now build this container using the <a href=\"https://docs.docker.com/engine/reference/commandline/build/\" target=\"_blank\" rel=\"noopener\"><code>docker build</code></a> command.</p>\n<h3>Step 2 : Build Docker Image</h3>\n<p>Type the following command to build your docker image:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t cpx-blog .</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the command above:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker build</code></td>\n<td>This basically tells the docker engine to build an image.</td>\n</tr>\n<tr>\n<td><code>-t</code></td>\n<td>This gives the image a name and optionally a tag in the <code>name:tag</code> format.</td>\n</tr>\n<tr>\n<td><code>cpx-blog</code></td>\n<td>This will be the name of the created docker image.</td>\n</tr>\n<tr>\n<td><code>.</code></td>\n<td>tells docker engine to look for a file named <em>Dockerfile</em> (by default) in the current directory.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>Optionally if you named your <code>Dockerfile</code> something different like <code>sandbox.dockerfile</code> you can append the <code>-f sandbox.dockerfile</code> flag after <code>build</code> statement.</p>\n</blockquote>\n<p>You will see the following output:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sending build context to Docker daemon  1.773MB</span><br><span class=\"line\">Step 1/6 : FROM fnichol/uhttpd</span><br><span class=\"line\">latest: Pulling from fnichol/uhttpd</span><br><span class=\"line\">a3ed95caeb02: Pull complete</span><br><span class=\"line\">1775fca35fb6: Pull complete</span><br><span class=\"line\">718e21306e6b: Pull complete</span><br><span class=\"line\">889bfeab2d4e: Pull complete</span><br><span class=\"line\">8ac43f1732b7: Pull complete</span><br><span class=\"line\">cefd08b5f834: Pull complete</span><br><span class=\"line\">a32be2ed7953: Pull complete</span><br><span class=\"line\">1c78be7a5ec7: Pull complete</span><br><span class=\"line\">74984e6e6d1c: Pull complete</span><br><span class=\"line\">Digest: sha256:28e6f95cf33ae1336525034e2b9d58ddf3cc63a2cdd9edebc8765321d96da9e0</span><br><span class=\"line\">Status: Downloaded newer image <span class=\"keyword\">for</span> fnichol/uhttpd:latest</span><br><span class=\"line\"> ---&gt; df0db1779d4d</span><br><span class=\"line\">Step 2/6 : MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 459db6d6a053</span><br><span class=\"line\"> ---&gt; d51effaba5ae</span><br><span class=\"line\">Removing intermediate container 459db6d6a053</span><br><span class=\"line\">Step 3/6 : COPY ./cpx-blog /www</span><br><span class=\"line\"> ---&gt; b1510a20020d</span><br><span class=\"line\">Removing intermediate container b075c62a629b</span><br><span class=\"line\">Step 4/6 : EXPOSE 80</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 84f5263cb817</span><br><span class=\"line\"> ---&gt; f1f4672c9d5b</span><br><span class=\"line\">Removing intermediate container 84f5263cb817</span><br><span class=\"line\">Step 5/6 : ENTRYPOINT /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 8e2b276c3aa9</span><br><span class=\"line\"> ---&gt; 552dfe1be7a7</span><br><span class=\"line\">Removing intermediate container 8e2b276c3aa9</span><br><span class=\"line\">Step 6/6 : CMD</span><br><span class=\"line\"> ---&gt; Running <span class=\"keyword\">in</span> 7c5da4990bea</span><br><span class=\"line\"> ---&gt; 0c78968bbe81</span><br><span class=\"line\">Removing intermediate container 7c5da4990bea</span><br><span class=\"line\">Successfully built 0c78968bbe81</span><br><span class=\"line\">Successfully tagged cpx-blog:latest</span><br></pre></td></tr></table></figure>\n<p>You can also see the images on the local host with the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker images</span><br></pre></td></tr></table></figure>\n<p>…which shows:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">cpx-blog            latest              0c78968bbe81        46 seconds ago      5.66MB</span><br><span class=\"line\">fnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB</span><br></pre></td></tr></table></figure>\n<p>Docker pulled the base image <code>fnichol/uhttpd</code> from Docker Hub as well as created the layer on top with the changes we added defined in our Dockerfile to create the <code>cpx-blog</code> image. This concludes the creation of the image. Next we will create <em>ONE</em> more image that is an updated version of the <code>cpx-blog</code> image before we run our containers in <a href=\"../Exercise-2\">Exercise-2</a>.</p>\n<h3>Step 3 : Tag a New Docker Image</h3>\n<p>Lets make updates to our <code>Dockerfile</code> in <code>/data/GoLang-cpx</code>. Open the file up in <code>nano</code> with the following command. <code>nano</code> is nothing more than a simple text editor for CLI. It can be considered an equivalent to <a href=\"https://www.sublimetext.com/\" target=\"_blank\" rel=\"noopener\">Sublime Text</a> or <a href=\"https://notepad-plus-plus.org/\" target=\"_blank\" rel=\"noopener\">Notepad++</a>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># In the /data/GoLang-cpx directory enter the following command:</span></span><br><span class=\"line\">sudo nano Dockerfile</span><br></pre></td></tr></table></figure>\n<p>Update the file with your cursor and keyboard to reflect the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM fnichol/uhttpd</span><br><span class=\"line\">MAINTAINER Mayank Tahilramani and Brian Tannous</span><br><span class=\"line\">COPY ./cpx-blog /www</span><br><span class=\"line\">WORKDIR /www</span><br><span class=\"line\">RUN echo &quot;find /www -type f -exec sed -i \\&quot;s/All rights reserved./Hosted by container: $&#123;HOSTNAME&#125;/g\\&quot; &#123;&#125; \\\\;&quot; &gt; /tmp/update.sh &amp;&amp; chmod +x /tmp/update.sh</span><br><span class=\"line\">EXPOSE 80</span><br><span class=\"line\">ENTRYPOINT /tmp/update.sh &amp;&amp; /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br><span class=\"line\">CMD [&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<pre><code>&gt;To exit `nano` after you are done editing, enter the keys `ctrl` + `x` then `y` and `enter` to save and quit.\n</code></pre>\n<p>Here are the details on the updated command lines added above:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /www</span><br></pre></td></tr></table></figure>\n<p>This changes the working directory of the docker build engine when executing <code>RUN</code> commands in the next line. Note that you cannot simply change directories by a single <code>RUN</code> command for example <code>cd /www</code> because each time you execute a <code>RUN</code> command, docker spawns a new container and therefore the default working directory become <code>/</code>. See more context <a href=\"https://stackoverflow.com/questions/17891981/docker-run-cd-does-not-work-as-expected\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN echo &quot;find /www -type f -exec sed -i \\&quot;s/All rights reserved./Hosted by container: $&#123;HOSTNAME&#125;/g\\&quot; &#123;&#125; \\\\;&quot; &gt; /tmp/update.sh &amp;&amp; chmod +x /tmp/update.sh</span><br></pre></td></tr></table></figure>\n<p>This command simply creates a script <code>/tmp/update.sh</code> which finds all files in the <code>/www</code> directory and replaces strings in them which match the pattern “<em>All rights reserved.</em>” with the string “<em>Hosted by container: ${HOSTNAME}</em>” where <code>${HOSTNAME}</code> is a built in environmental variable in the running container that holds the container’s unique host name. By default the hostname of any container is it’s short uuid. This script will essentially replace the footer of all web pages which state “All rights reserved” with which container is specifically hosting the website.</p>\n<blockquote>\n<p>Note that this command creates a script <code>/tmp/update.sh</code> but does not execute it. This command needs to be executed in a final running container state, not during an intermediate step when building the final image. Hence this script created here is executed in the <code>ENTRYPOINT</code> step below.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRYPOINT /tmp/update.sh &amp;&amp; /usr/sbin/run_uhttpd -f -p 80 -h /www</span><br></pre></td></tr></table></figure>\n<p>This command dictates what to execute when the container starts. Note that the <a href=\"https://medium.com/@lherrera/life-and-death-of-a-container-146dfc62f808\" target=\"_blank\" rel=\"noopener\">container’s lifespan</a> is directly dependent on the service it runs on start, in our case first the <code>/tmp/update.sh</code> script executes to update footers on all html pages, then the httpd (found at <code>/usr/sbin/run_uhttpd</code>) is executed. The entrypoint script basically starts the webservice hosting content in <code>/www</code>. If for whatever reason the uhttpd service itself fails, hangs, or stops, the running container will stop as well.</p>\n<p>With the updated changes in our Dockerfile, we have introduced a new script into the container <code>/tmp/update.sh</code> which updated some HTML text on our website and is executed upon running the container as defined by our <code>ENTRYPOINT</code> statement.</p>\n<p>Now lets build our new image:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># In the /data/GoLang-cpx directory enter the following command:</span></span><br><span class=\"line\">docker build -t cpx-blog:v2 .</span><br></pre></td></tr></table></figure>\n<p>View your images via the <code>docker images</code> command to see a new tagged version of the <code>cpx-blog</code> image was created.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WORKDIR /www</span><br><span class=\"line\">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class=\"line\">cpx-blog            v2                  7f4074f9eecf        9 seconds ago       5.66MB</span><br><span class=\"line\">cpx-blog            latest              0c78968bbe81        25 minutes ago      5.66MB</span><br><span class=\"line\">fnichol/uhttpd      latest              df0db1779d4d        3 years ago         4.87MB</span><br></pre></td></tr></table></figure>\n<h3>Review</h3>\n<p>In <strong><em>Step 1</em></strong> and <strong><em>Step 2</em></strong> we created 2 docker images of the same CPX-blog website. The first image was created using a Dockerfile form the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. The second image was created from a custom Dockerfile which added a script to update the footer of the website with the container’s hostname. Below is a overview of the steps above.</p>\n  <img src=\"/docker-101-mod2/docker-build.gif\" title=\"docker build\">\n<hr>\n<h2>Exercise 2 : Run a Docker Container</h2>\n<p>In this exercise we will create a two docker containers from two new images we created in the <a href=\"../Exercise-1\">previous exercise</a>. We will also create a third container that uses volume mounts to share persistent data with the docker host.</p>\n<h3>Step 1 : <code>sudo docker run</code></h3>\n<p>Lets run our first container based off the image we created from the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. Enter the following command to run your docker container:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --name=cpx-blog-1 -p 10000:80 cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the command:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th></th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>docker run -dt</code></td>\n<td></td>\n<td>This will run the container detached with a terminal in the background. Later we will see how we can attach to this container’s CLI, but for now we will have the container running detached in the background as a daemon.</td>\n</tr>\n<tr>\n<td><code>--name=cpx-blog-1</code></td>\n<td></td>\n<td>This gives the container a name for more intuitive reference in later docker commands. Without a name parameter, the container will be randomly assigned a name and can be referenced to via the random name or the hash id of the container.</td>\n</tr>\n<tr>\n<td><code>-p 10000:80</code></td>\n<td></td>\n<td>This will expose port <code>10000</code> on the host and map it to port <code>80</code> on the container for access to the hosted website.</td>\n</tr>\n<tr>\n<td><code>cpx-blog</code></td>\n<td></td>\n<td>This identifies the image we want to use by the docker engine to base our container off of. It will not bother pulling from Dockerhub because the image is already stored locally given you have completed <a href=\"../Exercise-1\">exercise 1</a>.</td>\n</tr>\n</tbody>\n</table>\n<p>You should receive an output of a long UID as a reference to the running container similar to <code>ed2348b56eda197a90313c8876ab4e6601b52406ba1c6740ccccd6e996565f60</code></p>\n<p>You can view the running container by entering in the <code>docker ps</code> command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES</span><br><span class=\"line\">ed2348b56eda        cpx-blog            &quot;/bin/sh -c &apos;/usr/...&quot;   About a minute ago   Up About a minute   0.0.0.0:10000-&gt;80/tcp   cpx-blog-1</span><br></pre></td></tr></table></figure>\n<p>Now lets view the website hosted by our docker container. If you are following along on your local machine, go to url <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<p>On the website, scroll down to the very bottom to notice the footer of this page stating: <code>2016. All rights reserved.</code> Make a note of this, because we are now going to run our new container that will have updated footer information.</p>\n  <img src=\"/docker-101-mod2/cpx-blog-1-footer.png\" title=\"cpx-blog-1 site\" alt=\"s footer\">\n<p>Lastly, lets remove this container so we can recycle the host port <code>10000</code> for our new container.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm -f cpx-blog-1</span><br></pre></td></tr></table></figure>\n<h3>Step 2 : Run an Updated Container</h3>\n<p>Lets run our second container based off the image we created from the modified version of the Dockerfile in the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. Enter the following command to run your docker container:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --name=cpx-blog-2 -p 10000:80 cpx-blog:v2</span><br></pre></td></tr></table></figure>\n<p>You can view the running container by entering in the <code>docker ps</code> command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                   NAMES</span><br><span class=\"line\">6e115d1c21f5        cpx-blog:v2            &quot;/bin/sh -c &apos;/usr/...&quot;   About a minute ago   Up About a minute   0.0.0.0:10000-&gt;80/tcp   cpx-blog-2</span><br></pre></td></tr></table></figure>\n<p>Now lets view the updated website hosted by our new docker container. If you are following along on your local machine, go to url <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<p>If you are following along in the sandbox environment, navigate your local browser to <a href=\"http://userX-lb.sl.americasreadiness.com\" target=\"_blank\" rel=\"noopener\">http://userX-lb.sl.americasreadiness.com</a> where <code>X</code> denotes your user number in the FQDN.</p>\n<p>On the website, scroll down to the very bottom and notice the footer of this page stating: <em>2016. Hosted by container: <strong>11ad31695df3</strong>.</em> The container hostname is showing up because of the <code>/tmp/update.sh</code> script that was executed when the container was run to update all <code>.html</code> footer code as defined in our new Dockerfile.</p>\n  <img src=\"/docker-101-mod2/cpx-blog-2-footer.png\" title=\"cpx-blog-2 site\" alt=\"s footer\">\n<p>Lastly, lets remove this container so we can recycle the host port <code>10000</code> for our new container.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm -f cpx-blog-2</span><br></pre></td></tr></table></figure>\n<h3>Step 3 : Persistent Volume Mounts</h3>\n<p>Thus far we have seen the docker container host the website with the <code>.html</code> data local to it’s file system. Ideally, you would not want to store any persistent data on the container itself, rather you should store in on some network or hyperconverged storage solution that the container can access as if local instead. This allow you to de-coupling storage of persistent data in the container from the compute processing done by the container itself and allows you to be more agile, spreads your failure domain, and scale independently in storage and compute capacity.</p>\n<p>In this In this step, we will run the same container as in <strong>step 1</strong>, but with a volume mount that shares a directory with the docker host mounted in the container to share persistent data. Enter the following command to run a docker container with a <a href=\"https://docs.docker.com/engine/reference/run/#volume-shared-filesystems\" target=\"_blank\" rel=\"noopener\">volume mount</a>.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker run -dt --name=cpx-blog-3 -p 10000:80 -v /data/GoLang-cpx/cpx-blog:/www:rw cpx-blog</span><br></pre></td></tr></table></figure>\n<p>Here is the breakdown of the new volume mount <code>-v</code> flag in the <code>docker run</code> command:</p>\n<table>\n<thead>\n<tr>\n<th>Command</th>\n<th></th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-v /data/GoLang-cpx/cpx-blog:/www:rw</code></td>\n<td></td>\n<td>The <code>-v</code> flag denotes that this container will have a volume mount that is located on the local host at <code>/data/GoLang-cpx/cpx-blog</code> and that directory will be mapped to the <code>/www</code> directory that is local to the container. The container will have <em>read/write</em> permissions to this directory as denoted by the <code>:rw</code> at the end.</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>\n<p>This flag allows us to remove the <code>COPY ./cpx-blog /www</code> command form our Dockerfile if desired to. However the pre-requisite of this container would become that a volume mount be provided at run time to host whatever content is in the mounted <code>/www</code> directory local to the container…</p>\n</li>\n<li>\n<p>Adding volume mounts of persistent data to containers saves space as well, because now the data isn’t replicated in each container, rather multiple containers can instead reference the same volume mount on a NFS network share, for example, mounted on the local docker host.</p>\n</li>\n<li>\n<p>Other services can also independently manipulate data in the volume mount directory on the host that have read-write access and it can be reflected in the running cpx-blog containers for example.</p>\n</li>\n</ul>\n<p>Once you have your container running, lets view the site hosted by our new docker container. If you are following along on your local machine, go to url <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<p>You will notice that the site looks identical to it did in <strong>Step 1</strong>. Lets change some content to the title page to prove a point.</p>\n<p>Enter the following command to edit text in the <code>index.html</code> of the home page of the blog:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo nano /data/GoLang-cpx/cpx-blog/index.html</span><br></pre></td></tr></table></figure>\n<p>Scroll down into the file where you see the line:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;NetScaler NITRO Blogs&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<p>update that line to look like :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;h1 class=&quot;brand-title&quot;&gt;LEARN DOCKER!&lt;/h1&gt;</span><br></pre></td></tr></table></figure>\n<p>Save and quit <code>nano</code> by entering the keys <code>ctrl</code> + <code>x</code> then <code>y</code> and <code>enter</code>.</p>\n<p>Now refresh your browser to the blog to view the updates changes. You should see a new title in the home page reflecting your changes to the <code>index.html</code></p>\n<p>Lastly, lets remove this container so we can recycle the host port <code>10000</code> for subsequent Modules.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker rm -f cpx-blog-3</span><br></pre></td></tr></table></figure>\n<h3>Review</h3>\n<p>In this module, we ran a container hosting our website using a Dockerfile in the <a href=\"https://github.com/Citrix-TechSpecialist/GoLang-cpx/\" target=\"_blank\" rel=\"noopener\">GoLang-cpx</a> repository. We also ran a container that has a script that ran at runtime to dynamically update the footer on each webpage to display the container’s hostname. Lastly, we deployed a third container that hosted the webpage through a volume mount where the data of the website only resided on the host and we showed that the data could be independently manipulated to reflect updates on our container hosted website.</p>\n<p>Here is an overview of the previous 3 steps.</p>\n  <img src=\"/docker-101-mod2/docker-run-new.gif\" title=\"docker run 3 containers\">"},{"title":"Introduction to Docker Compose","date":"2017-12-15T01:28:29.000Z","show":false,"_content":"\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n# Module 3: Using Docker Compose\n\nLet's assume by now you are familiar with basic Docker commands such as [`docker run`](https://docs.docker.com/engine/reference/run/#volume-shared-filesystems), [`docker ps`](https://docs.docker.com/engine/reference/commandline/ps/), [`docker pull`](https://docs.docker.com/engine/reference/commandline/pull/), [`docker rm`](https://docs.docker.com/engine/reference/commandline/rm/), and the various parameter flags (such as `-v` for volume mounts) associated with some of these commands.\n\nIt should also be obvious at this point that deploying docker containers at scale by hand with `docker run` commands can be very involved and, at time, too complicated with multiple lines of `docker ..` commands to deploy a large environment. Luckily, docker containers are not meant to be deployed via individual commands, rather they are often deployed to a desired state using various other tools that help automate and/or orchestrate microservices backed by docker containers. Some of these accompanying tools are provided below for reference.\n\n<!-- more --> \nDocker Tool | Details\n--- | ---\n[Kubernetes](https://kubernetes.io/) | Google's container orchestration and automation solution to schedule and maintain service state of docker containers.\n[Mesos](https://mesosphere.com/why-mesos/?utm_source=adwords&utm_medium=g&utm_campaign=43843512431&utm_term=mesos&utm_content=196225818929&gclid=CjwKEAjwtJzLBRC7z43vr63nr3wSJABjJDgJ_9xn3RWHnkH_nDjxQs1X8U6YgQ0drZPoOTfLv9-4hhoCqN3w_wcB)/[Marathon](https://mesosphere.github.io/marathon/) | Another Automation platform (Mesos) with an orchestration framework (Marathon) to ensure service state of docker containers.\n[Rancher](http://rancher.com/) | One of my favorites, complimentary to K8. Rancher is an opensource container management solution that makes it easy to deploy and manage containers in their own 'Cattle environments' and can even operate and manage other orchestration platforms like Kubernetes, Mesos/Marathon, and Docker Swarm.\n[Docker Swarm](https://docs.docker.com/swarm/overview/) | Docker's solution to automation and orchestration of clustered resources to provide a pool of Docker hosts into a single, virtual Docker host.\n[Docker Compose](https://docs.docker.com/compose/) | A automation tool for defining and running multi-container Docker applications. This tool is less sophisticated than the ones listed above and more simpler to use but with fewer features for larger deployments at scale.\n\n**In this module, we will be focusing on learning how to use Docker Compose to provision a self contained development environment based on a single input file that describes our desired state and configuration.**\n\n## Docker Compose \n\n>Source of description comes from [Docker's documentation](https://docs.docker.com/compose/overview/).\n\nCompose is a tool for defining and running multi-container Docker applications. With Compose, you use a Compose file to configure your application’s services. Then, using a single command, you create and start all the services from your configuration.\n\nUsing Compose is basically a three-step process.\n\n**Step 1**: Define your container with a `Dockerfile` so it can be reproduced anywhere. Either have provide the [Dockerfile as an input](https://docs.docker.com/compose/reference/build/) or have the defined container hosted in a [docker registry](https://docs.docker.com/registry/) like [docker hub](hub.docker.com/).\n\n**Step 2**: Define the containers that make up your microservices in a `docker-compose.yml` file so it can be run together with other containers in an isolated environment. The `docker-compose.yml` basically consist of `key` : `value` pairs as per the [yaml syntax](https://github.com/Animosity/CraftIRC/wiki/Complete-idiot's-introduction-to-yaml) describing the desired state of your services.\n\n**Step 3**: Lastly, run the command `docker-compose up` and Compose will start and run your entire microservice based app as per the desired state.\n\n## Overview\n\nIn this module, we are going to automate the deployment of a simple, self contained, dockerized [sandbox environment](https://github.com/Citrix-TechSpecialist/nitro-ide) to write scripts that issue [NITRO](http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html) commands to your NetScaler ADCs. In this case we will be issuing commands to a [NetScaler CPX](microloadbalancer.com) that will be locally provisioned on your machine to load balance simple containerized websites. However, it should be noted that this tutorial can be translated to develop and issue commands against other [NetScaler ADCs](https://www.citrix.com/products/netscaler-adc/platforms.html) as well if desired.\n\nThe desired environment will have the following topology:\n\n  {% asset_img topology.jpg Dev Box Topology %}\n\nServices | Details\n--- | ---\n**Webserver A** | Static containerized HTTP website\n**Webserver B** | Static containerized HTTP website\n**NetScaler CPX** | This will be the target NetScaler to send NITRO API calls to load balance webserver A and webserver B.\n**Cloud9 IDE** | Web-based Interactive Developer Environment that allows for rapid scripting and coding through a web browser.\n\n  >All the services above will be isolated in a dedicated [Docker Network](https://docs.docker.com/engine/userguide/networking/). Individual web interfaces that we will need direct external access to will have [external ports mapped](https://docs.docker.com/compose/compose-file/compose-file-v2/#ports) to the container for access from the underlay network (basically your host's LAN).\n\n---\n\n## Exercise 1 : Create docker-compose.yaml\n\nInstead of creating a `docker-compose.yml` file from scratch, we are going to copy one from another repository to get started. We will then examine the file and understand it's anatomy before finally making edits to suite our environment needs.\n\n### Step 1\n\nTo get started, enter the following commands to clone a repository with a `docker-compose.yml` file already made for us. Navigate to the directory and view the contents with `nano`.\n\n```bash\n# Change directory to the workspace you want to clone the repository\ncd /data\n\n# Clone the desired repository\nsudo git clone https://github.com/Citrix-TechSpecialist/nitro-ide.git\n\n# enter the directory of the repository\ncd nitro-ide\n\n# View the file contents of docker-compose.yml\nnano docker-compose.yml\n```\nHere is a copy of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> file for reference. It is recommended you open it in another tab in your browser to follow along.  \n\nBelow are the desired services we want to configure and deploy.\n\n  1. [Webserver A](https://hub.docker.com/r/mayankt/webserver/) that is a static website site\n  2. [Webserver B](https://hub.docker.com/r/mayankt/webserver/) that is a different static website\n  3. [Cloud9 IDE](https://c9.io/) which we will use to write code and execute python scripts to automate configuration of NetScaler CPX.\n  4. [NetScaler CPX](https://microloadbalancer.com) a NetScaler in a docker container that share the same API as other NetScaler ADCs.  \n\n### Explaining the docker-compose.yml File\n\nBelow are snippets of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">`docker-compose.yaml`</a>  with comments (`#`) per line with details of each `key` : `value` pairs describing the desired deployment.\n\n**Sandbox Network**\n\nWith Docker you can define specific container networks. In this case we are creating a [bridge network](https://docs.docker.com/engine/userguide/networking/#bridge-networks) specific to deploying only our desired containers to within a SDN boundary internal to the host.\n\n```\nnetworks:                             # This defines that below are settings for docker networks\n  sandbox:                            # Name of the network\n    driver: bridge                    # The type of network driver to use\n    ipam:                             # Details of the network and IP space\n      config:                         # Configuration parameters\n        - subnet: \"192.168.13.0/24\"   # The desired subnet of the docker network\n```\n\n**WebServer A / B**\n\n```\nwebserver-a/b:                         # Service name\n    image: \"mayankt/webserver:a\"       # Docker container image to use\n    restart: always                    # Restart the service if it fails or the host reboots\n    networks:                          # This describes the docker networks the containers will be part of\n      sandbox:                         # Docker network's name\n        ipv4_address: \"192.168.13.11\"  # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker's IPAM\n    hostname: webserver-a              # Desired hostname of the container\n```\n\n[**NetScaler CPX**](http://docs.citrix.com/en-us/netscaler-cpx/12/deploy-using-docker-image-file.html)\n\n```\n  cpx:                                               # Service Name\n    image: \"store/citrix/netscalercpx:12.0-41.16\"    # Docker container image to use from Citrix' registry\n    environment:\t\t\t\t\t\t\t\t\t                   # Environment Variables local to the container\n      EULA: \"yes\"\t\t\t\t\t\t\t\t\t                   # same as 'export EULA=\"yes\"' as a pre-req for CPX to work\n    restart: always                                  # Restart the service if it fails or the host reboots\n    cap_add:                                         # Add specific container kernel capabilities https://docs.docker.com/engine/security/security/#linux-kernel-capabilities\n      - NET_ADMIN                                    # Perform various network-related operations https://linux.die.net/man/7/capabilities\n    ulimits                                          # Override the default (resource) ulimits for a container\n      core: -1                                       # Use unlimited CPU, up to the amount available on the host system.\n    networks:                                        # This describes the docker networks the containers will be part of\n      sandbox:                                       # Docker network's name\n        ipv4_address: \"192.168.13.20\"                # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker's IPAM\n    ports:                                           # Exposed ports mapped to the host from the container.\n      - \"10000-10050:10000-10050\"\t\t\t\t\t\n      - \"9080:80\"\n    hostname: ns-adc                                 # Desired hostname of the container\n```\n\n[**Cloud9 IDE**](https://aws.amazon.com/cloud9/)\n\n```\n  nitro-ide:                          # Service Name\n    image: \"mayankt/nitro-ide\"        # Docker container image to use from Citrix' registry\n    restart: always                   # Restart the service if it fails or the host reboots\n    dns: 8.8.8.8                      # Specific DNS server to use for host name resolution from within the container\n    networks:                         # This describes the docker networks the containers will be part of\n      sandbox:                        # Docker network's name\n        ipv4_address: \"192.168.13.10\" # Static IP address of this service/\n    ports:                            # Exposed ports mapped to the host from the container.\n      - \"9090:80\"\n      - \"9091:8000\"\n    links:                            # Link to containers in another service given service name and/or a link alias (\"SERVICE:ALIAS\"). \"ping web-a\" will ping the webserver-a service from within the container.\n      - \"cpx\"\n      - \"webserver-a:web-a\"\n      - \"webserver-b:web-b\"\n    volumes:                          # Volume mounts local to the host mapped to a directory local to the container with read/write access (rw)\n        - ${DATA_DIR}:/workspace:rw      \n    hostname: nitro-ide               # Desired hostname of the container\n```\n> Note you may have to uncomment the `volumes` section to mount volumes in the docker file that is pulled from the repository. Use `nano` to remove the `#` from the `volumes:` block.\n\n### Step 2\n\nSet the environmental variable `DATA_DIR` to `/data` on the docker host. This environment variable will substitute the value `/data` into the docker compose file when we provision our containers. Type the following on your docker host:\n\n```\nexport DATA_DIR=\"/data\"`\n```\n\nVerify that the environmental variable was set successfully by typing the following command:\n\n```\necho $DATA_DIR\n```\n\nIt should return the `/data` directory path.\n\n### Review\n\nIn this module we clones a repository with our desired compose file. We explored what constitutes a `docker-compose.yml` file and what the various parameters mean. We set the value `/data` for a placeholder in the compose file that took in an environment variable to specify which local directory will be mapped to our IDE's local workspace `/workspace` so we can share data from host to container.\n\nHere is an overview of configuration steps:\n\n  {% asset_img docker-compose.gif docker-compose up -d %}\n\n---\n\n## Exercise 2 : Compose an Environment\n\nOnce you have your <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> set, you can move forward with provisioning your environment.\n\n### Step 1 : Provision an Environment\n\nIn the `/data/nitro-ide` directory, enter the following commands:\n\n```\n# Navigate to the repository local to your host\ncd /data/nitro-ide\n\n# Issue the docker compose command to provision your environment\ndocker-compose up -d\n```\n  > The `-d` in the [`docker-compose up -d`](https://docs.docker.com/compose/reference/up/) specifies that containers run in the background in detached mode.\n\nYou should observe an output similar to the following:\n\n```\nPulling cpx (store/citrix/netscalercpx:12.0-41.16)...\n12.0-41.16: Pulling from store/citrix/netscalercpx\n4e1f679e8ab4: Pull complete\n..\n..\n..\n588f5003e10f: Pull complete\nDigest: sha256:31a65cfa38833c747721c6fbc142faec6051e5f7b567d8b212d912b69b4f1ebe\nStatus: Downloaded newer image for store/citrix/netscalercpx:12.0-41.16\nPulling nitro-ide (mayankt/nitro-ide:latest)...\nlatest: Pulling from mayankt/nitro-ide\na3ed95caeb02: Pull complete\n..\n..\n..\n9581fa7fd579: Pull complete\nDigest: sha256:53c464876633e95f8e11ea821c50add0ff8e00a70c5aacd65f465d2d3045d8d3\nStatus: Downloaded newer image for mayankt/nitro-ide:latest\nPulling webserver-b (mayankt/webserver:b)...\nb: Pulling from mayankt/webserver\n3ac0c2aa6889: Pull complete\n..\n..\n..\n4484f1613730: Pull complete\nDigest: sha256:5807d78ba9c3892238a1eef2763c82f719d077b02a0c087122b816d276f0fbc4\nStatus: Downloaded newer image for mayankt/webserver:b\nPulling webserver-a (mayankt/webserver:a)...\na: Pulling from mayankt/webserver\n3ac0c2aa6889: Already exists\n..\n..\n..\nf128b2a739b4: Already exists\n1341f98ff817: Pull complete\nDigest: sha256:921d4054855c335dcd48a83bd881fa9059fa003f62f1b29bbe4b3a40fc79cc9a\nStatus: Downloaded newer image for mayankt/webserver:a\nCreating nitroide_webserver-b_1\nCreating nitroide_nitro-ide_1\nCreating nitroide_cpx_1\nCreating nitroide_webserver-a_1\n```\nYou can validate your desired containers are running by issuing a `docker ps` command to see all running containers.  \n\n```\nCONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS             \n                                                                     NAMES\n37892600b3d6        store/citrix/netscalercpx:12.0-41.16   \"/bin/sh -c 'bash ...\"   13 seconds ago      Up 10 seconds       22/tcp, 443/tcp, 1\n61/udp, 0.0.0.0:10000-10050->10000-10050/tcp, 0.0.0.0:9080->80/tcp   nitroide_cpx_1\n772b633440d7        mayankt/webserver:a                    \"/bin/sh -c 'nginx'\"     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   \n                                                                     nitroide_webserver-a_1\naeef73f08b84        mayankt/nitro-ide                      \"supervisord -c /e...\"   13 seconds ago      Up 11 seconds       3000/tcp, 0.0.0.0:\n9090->80/tcp, 0.0.0.0:9091->8000/tcp                                 nitroide_nitro-ide_1\nbb50c29a35c8        mayankt/webserver:b                    \"/bin/sh -c 'nginx'\"     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   \n                                                                     nitroide_webserver-b_1\n```\n\n### Step 2 : Access your IDE\n\nOnce all your containers are running successfully, navigate to your IDE's web console. On your local machine, go to url [http://localhost:9090](http://localhost:9090).\n\n  >Please wait up to 60 seconds for the IDE and CPX to fully load before they are accessible via the web console. Usually services are available within 30 seconds of deployment.\n\nYou should be greeted with Cloud9's loading page and then ultimately the IDE editor pane. Within the side pane you should notice your `workspace` directory and within that directory you should see the `nitro-ide` repository on your docker host.\n\nYou can select any file to open and edit it or to examine it. You even have access to the container's CLI terminal in the bottom pane. In the container's CLI pane within Cloud9 IDE, enter the following commands:\n\n```\ngit clone -b cpx-101 https://github.com/Citrix-TechSpecialist/NetScalerNITRO.git\n```\n\n### Step 3 : Execute Script from IDE\n\nA new directory will have been created `NetScalerNITRO` with the `nsAuto.py` python script that is pre-coded to configure the CPX to loadbalance webserver-a and webserver-b.\n\nIn the bottom pane within the container's CLI, enter the following commands to configure the CPX via NITRO scripted with Netscaler's Python SDK. Desired state configuration is specified in the `nsAutoCfg.json` file with pre-seeded default values for our environment (i.e. backend webserver IP's and CPX default username and pass along with its NSIP.)\n\n  >It is highly encouraged to open the `nsAuto.py` and `nsAutoCfg.json` file within the IDE to examine and learn from its contents and understand how the script is coded with NetScaler's NITRO Python SDK.\n\n```\ncd NetScalerNITRO\npython nsAuto.py\n```\n\nYou will see an output similar to:\n\n```\nConfiguring NS\nStarting to configure...\nAll done preforming configuration\n```\n\nThis indicates that the CPX has been configured successfully. It is load balancing Webserver A and Webserver B on its port 10000, using it's docker container IP in the sandbox docker network. Container port 10000 is mapped to host port 10000 so you can access your load balancer at [http://localhost:10000](http://localhost:10000).\n\n### Step 4 : Validate Configurations\n\nTo validate the configurations on the NetScaler CPX, enter the following commands on the Docker host to attach to the container's bash terminal:\n\n`docker exec -it nitroide_cpx_1 /bin/bash` and you will have entered into CPX's CLI.\n\nThen enter in the following NetScaler CLI commands to view configured vservers on the ADC with the following command:\n\n`cli_script.sh \"sh lb vservers\"` and you will see an output similar to the following for the configured vserver:\n\n```\n1)webserver (192.168.13.20:10000) - HTTPType: ADDRESS\nState: UP\nLast state change was at Fri Jul 14 02:02:23 2017\nTime since last state change: 0 days, 01:30:54.410\nEffective State: UP\nClient Idle Timeout: 180 sec\nDown state flush: ENABLED\nDisable Primary Vserver On Down : DISABLED\nAppflow logging: ENABLED\nPort Rewrite : DISABLED\nNo. of Bound Services :  2 (Total)  2 (Active)\nConfigured Method: ROUNDROBINBackupMethod: NONE\nMode: IP\nPersistence: NONE\nVserver IP and Port insertion: OFF\nPush: DISABLEDPush VServer:\nPush Multi Clients: NO\nPush Label Rule: none\nL2Conn: OFF\nSkip Persistency: None\nListen Policy: NONE\nIcmpResponse: PASSIVE\nRHIstate: PASSIVE\nNew Service Startup Request Rate: 0 PER_SECOND, Increment Interval: 0\nMac mode Retain Vlan: DISABLED\nDBS_LB: DISABLED\nProcess Local: DISABLED\nTraffic Domain: 0\nTROFS Persistence honored: ENABLED\nRetain Connections on Cluster: NO\n```\n\n### Review\n\nIn this exercise we deployed a sandbox development environment with an IDE, NetScaler CPX, and 2 simple webservers using docker compose. We then logged into the IDE and cloned a repository with python code that will automatically configure the NetScaler CPX using the pre-defined input file `nsAutoCfg.json` that provides details on the desired configuration state of the CPX. We validated that the websites were being load balanced and saw the running load balancer configuration on the CPX.\n\nHere is an overview of the procedures above:\n\n  {% asset_img docker-compose-up.gif docker compose up %}\n","source":"_posts/docker-101-mod3.md","raw":"---\ntitle: Introduction to Docker Compose\ntag:\n - [docker]\n - [sandbox]\n - [backdoor]\n - [container ide]\n - [docker-compose]\n - [dockerfile]\n - [docker-cli]\n - [cloud9]\n - [NetScaler]\n - [cpx]\n - [docker 101]\ncategory:\n  - [tutorials]\ndate: 2017-12-14 17:28:29\nshow: false\n---\n\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n# Module 3: Using Docker Compose\n\nLet's assume by now you are familiar with basic Docker commands such as [`docker run`](https://docs.docker.com/engine/reference/run/#volume-shared-filesystems), [`docker ps`](https://docs.docker.com/engine/reference/commandline/ps/), [`docker pull`](https://docs.docker.com/engine/reference/commandline/pull/), [`docker rm`](https://docs.docker.com/engine/reference/commandline/rm/), and the various parameter flags (such as `-v` for volume mounts) associated with some of these commands.\n\nIt should also be obvious at this point that deploying docker containers at scale by hand with `docker run` commands can be very involved and, at time, too complicated with multiple lines of `docker ..` commands to deploy a large environment. Luckily, docker containers are not meant to be deployed via individual commands, rather they are often deployed to a desired state using various other tools that help automate and/or orchestrate microservices backed by docker containers. Some of these accompanying tools are provided below for reference.\n\n<!-- more --> \nDocker Tool | Details\n--- | ---\n[Kubernetes](https://kubernetes.io/) | Google's container orchestration and automation solution to schedule and maintain service state of docker containers.\n[Mesos](https://mesosphere.com/why-mesos/?utm_source=adwords&utm_medium=g&utm_campaign=43843512431&utm_term=mesos&utm_content=196225818929&gclid=CjwKEAjwtJzLBRC7z43vr63nr3wSJABjJDgJ_9xn3RWHnkH_nDjxQs1X8U6YgQ0drZPoOTfLv9-4hhoCqN3w_wcB)/[Marathon](https://mesosphere.github.io/marathon/) | Another Automation platform (Mesos) with an orchestration framework (Marathon) to ensure service state of docker containers.\n[Rancher](http://rancher.com/) | One of my favorites, complimentary to K8. Rancher is an opensource container management solution that makes it easy to deploy and manage containers in their own 'Cattle environments' and can even operate and manage other orchestration platforms like Kubernetes, Mesos/Marathon, and Docker Swarm.\n[Docker Swarm](https://docs.docker.com/swarm/overview/) | Docker's solution to automation and orchestration of clustered resources to provide a pool of Docker hosts into a single, virtual Docker host.\n[Docker Compose](https://docs.docker.com/compose/) | A automation tool for defining and running multi-container Docker applications. This tool is less sophisticated than the ones listed above and more simpler to use but with fewer features for larger deployments at scale.\n\n**In this module, we will be focusing on learning how to use Docker Compose to provision a self contained development environment based on a single input file that describes our desired state and configuration.**\n\n## Docker Compose \n\n>Source of description comes from [Docker's documentation](https://docs.docker.com/compose/overview/).\n\nCompose is a tool for defining and running multi-container Docker applications. With Compose, you use a Compose file to configure your application’s services. Then, using a single command, you create and start all the services from your configuration.\n\nUsing Compose is basically a three-step process.\n\n**Step 1**: Define your container with a `Dockerfile` so it can be reproduced anywhere. Either have provide the [Dockerfile as an input](https://docs.docker.com/compose/reference/build/) or have the defined container hosted in a [docker registry](https://docs.docker.com/registry/) like [docker hub](hub.docker.com/).\n\n**Step 2**: Define the containers that make up your microservices in a `docker-compose.yml` file so it can be run together with other containers in an isolated environment. The `docker-compose.yml` basically consist of `key` : `value` pairs as per the [yaml syntax](https://github.com/Animosity/CraftIRC/wiki/Complete-idiot's-introduction-to-yaml) describing the desired state of your services.\n\n**Step 3**: Lastly, run the command `docker-compose up` and Compose will start and run your entire microservice based app as per the desired state.\n\n## Overview\n\nIn this module, we are going to automate the deployment of a simple, self contained, dockerized [sandbox environment](https://github.com/Citrix-TechSpecialist/nitro-ide) to write scripts that issue [NITRO](http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html) commands to your NetScaler ADCs. In this case we will be issuing commands to a [NetScaler CPX](microloadbalancer.com) that will be locally provisioned on your machine to load balance simple containerized websites. However, it should be noted that this tutorial can be translated to develop and issue commands against other [NetScaler ADCs](https://www.citrix.com/products/netscaler-adc/platforms.html) as well if desired.\n\nThe desired environment will have the following topology:\n\n  {% asset_img topology.jpg Dev Box Topology %}\n\nServices | Details\n--- | ---\n**Webserver A** | Static containerized HTTP website\n**Webserver B** | Static containerized HTTP website\n**NetScaler CPX** | This will be the target NetScaler to send NITRO API calls to load balance webserver A and webserver B.\n**Cloud9 IDE** | Web-based Interactive Developer Environment that allows for rapid scripting and coding through a web browser.\n\n  >All the services above will be isolated in a dedicated [Docker Network](https://docs.docker.com/engine/userguide/networking/). Individual web interfaces that we will need direct external access to will have [external ports mapped](https://docs.docker.com/compose/compose-file/compose-file-v2/#ports) to the container for access from the underlay network (basically your host's LAN).\n\n---\n\n## Exercise 1 : Create docker-compose.yaml\n\nInstead of creating a `docker-compose.yml` file from scratch, we are going to copy one from another repository to get started. We will then examine the file and understand it's anatomy before finally making edits to suite our environment needs.\n\n### Step 1\n\nTo get started, enter the following commands to clone a repository with a `docker-compose.yml` file already made for us. Navigate to the directory and view the contents with `nano`.\n\n```bash\n# Change directory to the workspace you want to clone the repository\ncd /data\n\n# Clone the desired repository\nsudo git clone https://github.com/Citrix-TechSpecialist/nitro-ide.git\n\n# enter the directory of the repository\ncd nitro-ide\n\n# View the file contents of docker-compose.yml\nnano docker-compose.yml\n```\nHere is a copy of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> file for reference. It is recommended you open it in another tab in your browser to follow along.  \n\nBelow are the desired services we want to configure and deploy.\n\n  1. [Webserver A](https://hub.docker.com/r/mayankt/webserver/) that is a static website site\n  2. [Webserver B](https://hub.docker.com/r/mayankt/webserver/) that is a different static website\n  3. [Cloud9 IDE](https://c9.io/) which we will use to write code and execute python scripts to automate configuration of NetScaler CPX.\n  4. [NetScaler CPX](https://microloadbalancer.com) a NetScaler in a docker container that share the same API as other NetScaler ADCs.  \n\n### Explaining the docker-compose.yml File\n\nBelow are snippets of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">`docker-compose.yaml`</a>  with comments (`#`) per line with details of each `key` : `value` pairs describing the desired deployment.\n\n**Sandbox Network**\n\nWith Docker you can define specific container networks. In this case we are creating a [bridge network](https://docs.docker.com/engine/userguide/networking/#bridge-networks) specific to deploying only our desired containers to within a SDN boundary internal to the host.\n\n```\nnetworks:                             # This defines that below are settings for docker networks\n  sandbox:                            # Name of the network\n    driver: bridge                    # The type of network driver to use\n    ipam:                             # Details of the network and IP space\n      config:                         # Configuration parameters\n        - subnet: \"192.168.13.0/24\"   # The desired subnet of the docker network\n```\n\n**WebServer A / B**\n\n```\nwebserver-a/b:                         # Service name\n    image: \"mayankt/webserver:a\"       # Docker container image to use\n    restart: always                    # Restart the service if it fails or the host reboots\n    networks:                          # This describes the docker networks the containers will be part of\n      sandbox:                         # Docker network's name\n        ipv4_address: \"192.168.13.11\"  # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker's IPAM\n    hostname: webserver-a              # Desired hostname of the container\n```\n\n[**NetScaler CPX**](http://docs.citrix.com/en-us/netscaler-cpx/12/deploy-using-docker-image-file.html)\n\n```\n  cpx:                                               # Service Name\n    image: \"store/citrix/netscalercpx:12.0-41.16\"    # Docker container image to use from Citrix' registry\n    environment:\t\t\t\t\t\t\t\t\t                   # Environment Variables local to the container\n      EULA: \"yes\"\t\t\t\t\t\t\t\t\t                   # same as 'export EULA=\"yes\"' as a pre-req for CPX to work\n    restart: always                                  # Restart the service if it fails or the host reboots\n    cap_add:                                         # Add specific container kernel capabilities https://docs.docker.com/engine/security/security/#linux-kernel-capabilities\n      - NET_ADMIN                                    # Perform various network-related operations https://linux.die.net/man/7/capabilities\n    ulimits                                          # Override the default (resource) ulimits for a container\n      core: -1                                       # Use unlimited CPU, up to the amount available on the host system.\n    networks:                                        # This describes the docker networks the containers will be part of\n      sandbox:                                       # Docker network's name\n        ipv4_address: \"192.168.13.20\"                # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker's IPAM\n    ports:                                           # Exposed ports mapped to the host from the container.\n      - \"10000-10050:10000-10050\"\t\t\t\t\t\n      - \"9080:80\"\n    hostname: ns-adc                                 # Desired hostname of the container\n```\n\n[**Cloud9 IDE**](https://aws.amazon.com/cloud9/)\n\n```\n  nitro-ide:                          # Service Name\n    image: \"mayankt/nitro-ide\"        # Docker container image to use from Citrix' registry\n    restart: always                   # Restart the service if it fails or the host reboots\n    dns: 8.8.8.8                      # Specific DNS server to use for host name resolution from within the container\n    networks:                         # This describes the docker networks the containers will be part of\n      sandbox:                        # Docker network's name\n        ipv4_address: \"192.168.13.10\" # Static IP address of this service/\n    ports:                            # Exposed ports mapped to the host from the container.\n      - \"9090:80\"\n      - \"9091:8000\"\n    links:                            # Link to containers in another service given service name and/or a link alias (\"SERVICE:ALIAS\"). \"ping web-a\" will ping the webserver-a service from within the container.\n      - \"cpx\"\n      - \"webserver-a:web-a\"\n      - \"webserver-b:web-b\"\n    volumes:                          # Volume mounts local to the host mapped to a directory local to the container with read/write access (rw)\n        - ${DATA_DIR}:/workspace:rw      \n    hostname: nitro-ide               # Desired hostname of the container\n```\n> Note you may have to uncomment the `volumes` section to mount volumes in the docker file that is pulled from the repository. Use `nano` to remove the `#` from the `volumes:` block.\n\n### Step 2\n\nSet the environmental variable `DATA_DIR` to `/data` on the docker host. This environment variable will substitute the value `/data` into the docker compose file when we provision our containers. Type the following on your docker host:\n\n```\nexport DATA_DIR=\"/data\"`\n```\n\nVerify that the environmental variable was set successfully by typing the following command:\n\n```\necho $DATA_DIR\n```\n\nIt should return the `/data` directory path.\n\n### Review\n\nIn this module we clones a repository with our desired compose file. We explored what constitutes a `docker-compose.yml` file and what the various parameters mean. We set the value `/data` for a placeholder in the compose file that took in an environment variable to specify which local directory will be mapped to our IDE's local workspace `/workspace` so we can share data from host to container.\n\nHere is an overview of configuration steps:\n\n  {% asset_img docker-compose.gif docker-compose up -d %}\n\n---\n\n## Exercise 2 : Compose an Environment\n\nOnce you have your <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> set, you can move forward with provisioning your environment.\n\n### Step 1 : Provision an Environment\n\nIn the `/data/nitro-ide` directory, enter the following commands:\n\n```\n# Navigate to the repository local to your host\ncd /data/nitro-ide\n\n# Issue the docker compose command to provision your environment\ndocker-compose up -d\n```\n  > The `-d` in the [`docker-compose up -d`](https://docs.docker.com/compose/reference/up/) specifies that containers run in the background in detached mode.\n\nYou should observe an output similar to the following:\n\n```\nPulling cpx (store/citrix/netscalercpx:12.0-41.16)...\n12.0-41.16: Pulling from store/citrix/netscalercpx\n4e1f679e8ab4: Pull complete\n..\n..\n..\n588f5003e10f: Pull complete\nDigest: sha256:31a65cfa38833c747721c6fbc142faec6051e5f7b567d8b212d912b69b4f1ebe\nStatus: Downloaded newer image for store/citrix/netscalercpx:12.0-41.16\nPulling nitro-ide (mayankt/nitro-ide:latest)...\nlatest: Pulling from mayankt/nitro-ide\na3ed95caeb02: Pull complete\n..\n..\n..\n9581fa7fd579: Pull complete\nDigest: sha256:53c464876633e95f8e11ea821c50add0ff8e00a70c5aacd65f465d2d3045d8d3\nStatus: Downloaded newer image for mayankt/nitro-ide:latest\nPulling webserver-b (mayankt/webserver:b)...\nb: Pulling from mayankt/webserver\n3ac0c2aa6889: Pull complete\n..\n..\n..\n4484f1613730: Pull complete\nDigest: sha256:5807d78ba9c3892238a1eef2763c82f719d077b02a0c087122b816d276f0fbc4\nStatus: Downloaded newer image for mayankt/webserver:b\nPulling webserver-a (mayankt/webserver:a)...\na: Pulling from mayankt/webserver\n3ac0c2aa6889: Already exists\n..\n..\n..\nf128b2a739b4: Already exists\n1341f98ff817: Pull complete\nDigest: sha256:921d4054855c335dcd48a83bd881fa9059fa003f62f1b29bbe4b3a40fc79cc9a\nStatus: Downloaded newer image for mayankt/webserver:a\nCreating nitroide_webserver-b_1\nCreating nitroide_nitro-ide_1\nCreating nitroide_cpx_1\nCreating nitroide_webserver-a_1\n```\nYou can validate your desired containers are running by issuing a `docker ps` command to see all running containers.  \n\n```\nCONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS             \n                                                                     NAMES\n37892600b3d6        store/citrix/netscalercpx:12.0-41.16   \"/bin/sh -c 'bash ...\"   13 seconds ago      Up 10 seconds       22/tcp, 443/tcp, 1\n61/udp, 0.0.0.0:10000-10050->10000-10050/tcp, 0.0.0.0:9080->80/tcp   nitroide_cpx_1\n772b633440d7        mayankt/webserver:a                    \"/bin/sh -c 'nginx'\"     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   \n                                                                     nitroide_webserver-a_1\naeef73f08b84        mayankt/nitro-ide                      \"supervisord -c /e...\"   13 seconds ago      Up 11 seconds       3000/tcp, 0.0.0.0:\n9090->80/tcp, 0.0.0.0:9091->8000/tcp                                 nitroide_nitro-ide_1\nbb50c29a35c8        mayankt/webserver:b                    \"/bin/sh -c 'nginx'\"     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   \n                                                                     nitroide_webserver-b_1\n```\n\n### Step 2 : Access your IDE\n\nOnce all your containers are running successfully, navigate to your IDE's web console. On your local machine, go to url [http://localhost:9090](http://localhost:9090).\n\n  >Please wait up to 60 seconds for the IDE and CPX to fully load before they are accessible via the web console. Usually services are available within 30 seconds of deployment.\n\nYou should be greeted with Cloud9's loading page and then ultimately the IDE editor pane. Within the side pane you should notice your `workspace` directory and within that directory you should see the `nitro-ide` repository on your docker host.\n\nYou can select any file to open and edit it or to examine it. You even have access to the container's CLI terminal in the bottom pane. In the container's CLI pane within Cloud9 IDE, enter the following commands:\n\n```\ngit clone -b cpx-101 https://github.com/Citrix-TechSpecialist/NetScalerNITRO.git\n```\n\n### Step 3 : Execute Script from IDE\n\nA new directory will have been created `NetScalerNITRO` with the `nsAuto.py` python script that is pre-coded to configure the CPX to loadbalance webserver-a and webserver-b.\n\nIn the bottom pane within the container's CLI, enter the following commands to configure the CPX via NITRO scripted with Netscaler's Python SDK. Desired state configuration is specified in the `nsAutoCfg.json` file with pre-seeded default values for our environment (i.e. backend webserver IP's and CPX default username and pass along with its NSIP.)\n\n  >It is highly encouraged to open the `nsAuto.py` and `nsAutoCfg.json` file within the IDE to examine and learn from its contents and understand how the script is coded with NetScaler's NITRO Python SDK.\n\n```\ncd NetScalerNITRO\npython nsAuto.py\n```\n\nYou will see an output similar to:\n\n```\nConfiguring NS\nStarting to configure...\nAll done preforming configuration\n```\n\nThis indicates that the CPX has been configured successfully. It is load balancing Webserver A and Webserver B on its port 10000, using it's docker container IP in the sandbox docker network. Container port 10000 is mapped to host port 10000 so you can access your load balancer at [http://localhost:10000](http://localhost:10000).\n\n### Step 4 : Validate Configurations\n\nTo validate the configurations on the NetScaler CPX, enter the following commands on the Docker host to attach to the container's bash terminal:\n\n`docker exec -it nitroide_cpx_1 /bin/bash` and you will have entered into CPX's CLI.\n\nThen enter in the following NetScaler CLI commands to view configured vservers on the ADC with the following command:\n\n`cli_script.sh \"sh lb vservers\"` and you will see an output similar to the following for the configured vserver:\n\n```\n1)webserver (192.168.13.20:10000) - HTTPType: ADDRESS\nState: UP\nLast state change was at Fri Jul 14 02:02:23 2017\nTime since last state change: 0 days, 01:30:54.410\nEffective State: UP\nClient Idle Timeout: 180 sec\nDown state flush: ENABLED\nDisable Primary Vserver On Down : DISABLED\nAppflow logging: ENABLED\nPort Rewrite : DISABLED\nNo. of Bound Services :  2 (Total)  2 (Active)\nConfigured Method: ROUNDROBINBackupMethod: NONE\nMode: IP\nPersistence: NONE\nVserver IP and Port insertion: OFF\nPush: DISABLEDPush VServer:\nPush Multi Clients: NO\nPush Label Rule: none\nL2Conn: OFF\nSkip Persistency: None\nListen Policy: NONE\nIcmpResponse: PASSIVE\nRHIstate: PASSIVE\nNew Service Startup Request Rate: 0 PER_SECOND, Increment Interval: 0\nMac mode Retain Vlan: DISABLED\nDBS_LB: DISABLED\nProcess Local: DISABLED\nTraffic Domain: 0\nTROFS Persistence honored: ENABLED\nRetain Connections on Cluster: NO\n```\n\n### Review\n\nIn this exercise we deployed a sandbox development environment with an IDE, NetScaler CPX, and 2 simple webservers using docker compose. We then logged into the IDE and cloned a repository with python code that will automatically configure the NetScaler CPX using the pre-defined input file `nsAutoCfg.json` that provides details on the desired configuration state of the CPX. We validated that the websites were being load balanced and saw the running load balancer configuration on the CPX.\n\nHere is an overview of the procedures above:\n\n  {% asset_img docker-compose-up.gif docker compose up %}\n","slug":"docker-101-mod3","published":1,"updated":"2017-12-15T07:42:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb8926jn000dpbml5l0x8ysv","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Module 3: Using Docker Compose</h1>\n<p>Let’s assume by now you are familiar with basic Docker commands such as <a href=\"https://docs.docker.com/engine/reference/run/#volume-shared-filesystems\" target=\"_blank\" rel=\"noopener\"><code>docker run</code></a>, <a href=\"https://docs.docker.com/engine/reference/commandline/ps/\" target=\"_blank\" rel=\"noopener\"><code>docker ps</code></a>, <a href=\"https://docs.docker.com/engine/reference/commandline/pull/\" target=\"_blank\" rel=\"noopener\"><code>docker pull</code></a>, <a href=\"https://docs.docker.com/engine/reference/commandline/rm/\" target=\"_blank\" rel=\"noopener\"><code>docker rm</code></a>, and the various parameter flags (such as <code>-v</code> for volume mounts) associated with some of these commands.</p>\n<p>It should also be obvious at this point that deploying docker containers at scale by hand with <code>docker run</code> commands can be very involved and, at time, too complicated with multiple lines of <code>docker ..</code> commands to deploy a large environment. Luckily, docker containers are not meant to be deployed via individual commands, rather they are often deployed to a desired state using various other tools that help automate and/or orchestrate microservices backed by docker containers. Some of these accompanying tools are provided below for reference.</p>\n<a id=\"more\"></a> \n<table>\n<thead>\n<tr>\n<th>Docker Tool</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener\">Kubernetes</a></td>\n<td>Google’s container orchestration and automation solution to schedule and maintain service state of docker containers.</td>\n</tr>\n<tr>\n<td><a href=\"https://mesosphere.com/why-mesos/?utm_source=adwords&amp;utm_medium=g&amp;utm_campaign=43843512431&amp;utm_term=mesos&amp;utm_content=196225818929&amp;gclid=CjwKEAjwtJzLBRC7z43vr63nr3wSJABjJDgJ_9xn3RWHnkH_nDjxQs1X8U6YgQ0drZPoOTfLv9-4hhoCqN3w_wcB\" target=\"_blank\" rel=\"noopener\">Mesos</a>/<a href=\"https://mesosphere.github.io/marathon/\" target=\"_blank\" rel=\"noopener\">Marathon</a></td>\n<td>Another Automation platform (Mesos) with an orchestration framework (Marathon) to ensure service state of docker containers.</td>\n</tr>\n<tr>\n<td><a href=\"http://rancher.com/\" target=\"_blank\" rel=\"noopener\">Rancher</a></td>\n<td>One of my favorites, complimentary to K8. Rancher is an opensource container management solution that makes it easy to deploy and manage containers in their own ‘Cattle environments’ and can even operate and manage other orchestration platforms like Kubernetes, Mesos/Marathon, and Docker Swarm.</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.docker.com/swarm/overview/\" target=\"_blank\" rel=\"noopener\">Docker Swarm</a></td>\n<td>Docker’s solution to automation and orchestration of clustered resources to provide a pool of Docker hosts into a single, virtual Docker host.</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.docker.com/compose/\" target=\"_blank\" rel=\"noopener\">Docker Compose</a></td>\n<td>A automation tool for defining and running multi-container Docker applications. This tool is less sophisticated than the ones listed above and more simpler to use but with fewer features for larger deployments at scale.</td>\n</tr>\n</tbody>\n</table>\n<p><strong>In this module, we will be focusing on learning how to use Docker Compose to provision a self contained development environment based on a single input file that describes our desired state and configuration.</strong></p>\n<h2>Docker Compose</h2>\n<blockquote>\n<p>Source of description comes from <a href=\"https://docs.docker.com/compose/overview/\" target=\"_blank\" rel=\"noopener\">Docker’s documentation</a>.</p>\n</blockquote>\n<p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a Compose file to configure your application’s services. Then, using a single command, you create and start all the services from your configuration.</p>\n<p>Using Compose is basically a three-step process.</p>\n<p><strong>Step 1</strong>: Define your container with a <code>Dockerfile</code> so it can be reproduced anywhere. Either have provide the <a href=\"https://docs.docker.com/compose/reference/build/\" target=\"_blank\" rel=\"noopener\">Dockerfile as an input</a> or have the defined container hosted in a <a href=\"https://docs.docker.com/registry/\" target=\"_blank\" rel=\"noopener\">docker registry</a> like <a href=\"hub.docker.com/\">docker hub</a>.</p>\n<p><strong>Step 2</strong>: Define the containers that make up your microservices in a <code>docker-compose.yml</code> file so it can be run together with other containers in an isolated environment. The <code>docker-compose.yml</code> basically consist of <code>key</code> : <code>value</code> pairs as per the <a href=\"https://github.com/Animosity/CraftIRC/wiki/Complete-idiot's-introduction-to-yaml\" target=\"_blank\" rel=\"noopener\">yaml syntax</a> describing the desired state of your services.</p>\n<p><strong>Step 3</strong>: Lastly, run the command <code>docker-compose up</code> and Compose will start and run your entire microservice based app as per the desired state.</p>\n<h2>Overview</h2>\n<p>In this module, we are going to automate the deployment of a simple, self contained, dockerized <a href=\"https://github.com/Citrix-TechSpecialist/nitro-ide\" target=\"_blank\" rel=\"noopener\">sandbox environment</a> to write scripts that issue <a href=\"http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html\" target=\"_blank\" rel=\"noopener\">NITRO</a> commands to your NetScaler ADCs. In this case we will be issuing commands to a <a href=\"microloadbalancer.com\">NetScaler CPX</a> that will be locally provisioned on your machine to load balance simple containerized websites. However, it should be noted that this tutorial can be translated to develop and issue commands against other <a href=\"https://www.citrix.com/products/netscaler-adc/platforms.html\" target=\"_blank\" rel=\"noopener\">NetScaler ADCs</a> as well if desired.</p>\n<p>The desired environment will have the following topology:</p>\n  <img src=\"/docker-101-mod3/topology.jpg\" title=\"Dev Box Topology\">\n<table>\n<thead>\n<tr>\n<th>Services</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Webserver A</strong></td>\n<td>Static containerized HTTP website</td>\n</tr>\n<tr>\n<td><strong>Webserver B</strong></td>\n<td>Static containerized HTTP website</td>\n</tr>\n<tr>\n<td><strong>NetScaler CPX</strong></td>\n<td>This will be the target NetScaler to send NITRO API calls to load balance webserver A and webserver B.</td>\n</tr>\n<tr>\n<td><strong>Cloud9 IDE</strong></td>\n<td>Web-based Interactive Developer Environment that allows for rapid scripting and coding through a web browser.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>All the services above will be isolated in a dedicated <a href=\"https://docs.docker.com/engine/userguide/networking/\" target=\"_blank\" rel=\"noopener\">Docker Network</a>. Individual web interfaces that we will need direct external access to will have <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v2/#ports\" target=\"_blank\" rel=\"noopener\">external ports mapped</a> to the container for access from the underlay network (basically your host’s LAN).</p>\n</blockquote>\n<hr>\n<h2>Exercise 1 : Create docker-compose.yaml</h2>\n<p>Instead of creating a <code>docker-compose.yml</code> file from scratch, we are going to copy one from another repository to get started. We will then examine the file and understand it’s anatomy before finally making edits to suite our environment needs.</p>\n<h3>Step 1</h3>\n<p>To get started, enter the following commands to clone a repository with a <code>docker-compose.yml</code> file already made for us. Navigate to the directory and view the contents with <code>nano</code>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Change directory to the workspace you want to clone the repository</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clone the desired repository</span></span><br><span class=\"line\">sudo git <span class=\"built_in\">clone</span> https://github.com/Citrix-TechSpecialist/nitro-ide.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># enter the directory of the repository</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nitro-ide</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># View the file contents of docker-compose.yml</span></span><br><span class=\"line\">nano docker-compose.yml</span><br></pre></td></tr></table></figure>\n<p>Here is a copy of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> file for reference. It is recommended you open it in another tab in your browser to follow along.</p>\n<p>Below are the desired services we want to configure and deploy.</p>\n<ol>\n<li><a href=\"https://hub.docker.com/r/mayankt/webserver/\" target=\"_blank\" rel=\"noopener\">Webserver A</a> that is a static website site</li>\n<li><a href=\"https://hub.docker.com/r/mayankt/webserver/\" target=\"_blank\" rel=\"noopener\">Webserver B</a> that is a different static website</li>\n<li><a href=\"https://c9.io/\" target=\"_blank\" rel=\"noopener\">Cloud9 IDE</a> which we will use to write code and execute python scripts to automate configuration of NetScaler CPX.</li>\n<li><a href=\"https://microloadbalancer.com\" target=\"_blank\" rel=\"noopener\">NetScaler CPX</a> a NetScaler in a docker container that share the same API as other NetScaler ADCs.</li>\n</ol>\n<h3>Explaining the docker-compose.yml File</h3>\n<p>Below are snippets of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\"><code>docker-compose.yaml</code></a>  with comments (<code>#</code>) per line with details of each <code>key</code> : <code>value</code> pairs describing the desired deployment.</p>\n<p><strong>Sandbox Network</strong></p>\n<p>With Docker you can define specific container networks. In this case we are creating a <a href=\"https://docs.docker.com/engine/userguide/networking/#bridge-networks\" target=\"_blank\" rel=\"noopener\">bridge network</a> specific to deploying only our desired containers to within a SDN boundary internal to the host.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">networks:                             # This defines that below are settings for docker networks</span><br><span class=\"line\">  sandbox:                            # Name of the network</span><br><span class=\"line\">    driver: bridge                    # The type of network driver to use</span><br><span class=\"line\">    ipam:                             # Details of the network and IP space</span><br><span class=\"line\">      config:                         # Configuration parameters</span><br><span class=\"line\">        - subnet: &quot;192.168.13.0/24&quot;   # The desired subnet of the docker network</span><br></pre></td></tr></table></figure>\n<p><strong>WebServer A / B</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webserver-a/b:                         # Service name</span><br><span class=\"line\">    image: &quot;mayankt/webserver:a&quot;       # Docker container image to use</span><br><span class=\"line\">    restart: always                    # Restart the service if it fails or the host reboots</span><br><span class=\"line\">    networks:                          # This describes the docker networks the containers will be part of</span><br><span class=\"line\">      sandbox:                         # Docker network&apos;s name</span><br><span class=\"line\">        ipv4_address: &quot;192.168.13.11&quot;  # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker&apos;s IPAM</span><br><span class=\"line\">    hostname: webserver-a              # Desired hostname of the container</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://docs.citrix.com/en-us/netscaler-cpx/12/deploy-using-docker-image-file.html\" target=\"_blank\" rel=\"noopener\"><strong>NetScaler CPX</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpx:                                               # Service Name</span><br><span class=\"line\">  image: &quot;store/citrix/netscalercpx:12.0-41.16&quot;    # Docker container image to use from Citrix&apos; registry</span><br><span class=\"line\">  environment:\t\t\t\t\t\t\t\t\t                   # Environment Variables local to the container</span><br><span class=\"line\">    EULA: &quot;yes&quot;\t\t\t\t\t\t\t\t\t                   # same as &apos;export EULA=&quot;yes&quot;&apos; as a pre-req for CPX to work</span><br><span class=\"line\">  restart: always                                  # Restart the service if it fails or the host reboots</span><br><span class=\"line\">  cap_add:                                         # Add specific container kernel capabilities https://docs.docker.com/engine/security/security/#linux-kernel-capabilities</span><br><span class=\"line\">    - NET_ADMIN                                    # Perform various network-related operations https://linux.die.net/man/7/capabilities</span><br><span class=\"line\">  ulimits                                          # Override the default (resource) ulimits for a container</span><br><span class=\"line\">    core: -1                                       # Use unlimited CPU, up to the amount available on the host system.</span><br><span class=\"line\">  networks:                                        # This describes the docker networks the containers will be part of</span><br><span class=\"line\">    sandbox:                                       # Docker network&apos;s name</span><br><span class=\"line\">      ipv4_address: &quot;192.168.13.20&quot;                # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker&apos;s IPAM</span><br><span class=\"line\">  ports:                                           # Exposed ports mapped to the host from the container.</span><br><span class=\"line\">    - &quot;10000-10050:10000-10050&quot;\t\t\t\t\t</span><br><span class=\"line\">    - &quot;9080:80&quot;</span><br><span class=\"line\">  hostname: ns-adc                                 # Desired hostname of the container</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://aws.amazon.com/cloud9/\" target=\"_blank\" rel=\"noopener\"><strong>Cloud9 IDE</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nitro-ide:                          # Service Name</span><br><span class=\"line\">  image: &quot;mayankt/nitro-ide&quot;        # Docker container image to use from Citrix&apos; registry</span><br><span class=\"line\">  restart: always                   # Restart the service if it fails or the host reboots</span><br><span class=\"line\">  dns: 8.8.8.8                      # Specific DNS server to use for host name resolution from within the container</span><br><span class=\"line\">  networks:                         # This describes the docker networks the containers will be part of</span><br><span class=\"line\">    sandbox:                        # Docker network&apos;s name</span><br><span class=\"line\">      ipv4_address: &quot;192.168.13.10&quot; # Static IP address of this service/</span><br><span class=\"line\">  ports:                            # Exposed ports mapped to the host from the container.</span><br><span class=\"line\">    - &quot;9090:80&quot;</span><br><span class=\"line\">    - &quot;9091:8000&quot;</span><br><span class=\"line\">  links:                            # Link to containers in another service given service name and/or a link alias (&quot;SERVICE:ALIAS&quot;). &quot;ping web-a&quot; will ping the webserver-a service from within the container.</span><br><span class=\"line\">    - &quot;cpx&quot;</span><br><span class=\"line\">    - &quot;webserver-a:web-a&quot;</span><br><span class=\"line\">    - &quot;webserver-b:web-b&quot;</span><br><span class=\"line\">  volumes:                          # Volume mounts local to the host mapped to a directory local to the container with read/write access (rw)</span><br><span class=\"line\">      - $&#123;DATA_DIR&#125;:/workspace:rw      </span><br><span class=\"line\">  hostname: nitro-ide               # Desired hostname of the container</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note you may have to uncomment the <code>volumes</code> section to mount volumes in the docker file that is pulled from the repository. Use <code>nano</code> to remove the <code>#</code> from the <code>volumes:</code> block.</p>\n</blockquote>\n<h3>Step 2</h3>\n<p>Set the environmental variable <code>DATA_DIR</code> to <code>/data</code> on the docker host. This environment variable will substitute the value <code>/data</code> into the docker compose file when we provision our containers. Type the following on your docker host:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export DATA_DIR=&quot;/data&quot;`</span><br></pre></td></tr></table></figure>\n<p>Verify that the environmental variable was set successfully by typing the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $DATA_DIR</span><br></pre></td></tr></table></figure>\n<p>It should return the <code>/data</code> directory path.</p>\n<h3>Review</h3>\n<p>In this module we clones a repository with our desired compose file. We explored what constitutes a <code>docker-compose.yml</code> file and what the various parameters mean. We set the value <code>/data</code> for a placeholder in the compose file that took in an environment variable to specify which local directory will be mapped to our IDE’s local workspace <code>/workspace</code> so we can share data from host to container.</p>\n<p>Here is an overview of configuration steps:</p>\n  <img src=\"/docker-101-mod3/docker-compose.gif\" title=\"docker-compose up -d\">\n<hr>\n<h2>Exercise 2 : Compose an Environment</h2>\n<p>Once you have your <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> set, you can move forward with provisioning your environment.</p>\n<h3>Step 1 : Provision an Environment</h3>\n<p>In the <code>/data/nitro-ide</code> directory, enter the following commands:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Navigate to the repository local to your host</span><br><span class=\"line\">cd /data/nitro-ide</span><br><span class=\"line\"></span><br><span class=\"line\"># Issue the docker compose command to provision your environment</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The <code>-d</code> in the <a href=\"https://docs.docker.com/compose/reference/up/\" target=\"_blank\" rel=\"noopener\"><code>docker-compose up -d</code></a> specifies that containers run in the background in detached mode.</p>\n</blockquote>\n<p>You should observe an output similar to the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pulling cpx (store/citrix/netscalercpx:12.0-41.16)...</span><br><span class=\"line\">12.0-41.16: Pulling from store/citrix/netscalercpx</span><br><span class=\"line\">4e1f679e8ab4: Pull complete</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">588f5003e10f: Pull complete</span><br><span class=\"line\">Digest: sha256:31a65cfa38833c747721c6fbc142faec6051e5f7b567d8b212d912b69b4f1ebe</span><br><span class=\"line\">Status: Downloaded newer image for store/citrix/netscalercpx:12.0-41.16</span><br><span class=\"line\">Pulling nitro-ide (mayankt/nitro-ide:latest)...</span><br><span class=\"line\">latest: Pulling from mayankt/nitro-ide</span><br><span class=\"line\">a3ed95caeb02: Pull complete</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">9581fa7fd579: Pull complete</span><br><span class=\"line\">Digest: sha256:53c464876633e95f8e11ea821c50add0ff8e00a70c5aacd65f465d2d3045d8d3</span><br><span class=\"line\">Status: Downloaded newer image for mayankt/nitro-ide:latest</span><br><span class=\"line\">Pulling webserver-b (mayankt/webserver:b)...</span><br><span class=\"line\">b: Pulling from mayankt/webserver</span><br><span class=\"line\">3ac0c2aa6889: Pull complete</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">4484f1613730: Pull complete</span><br><span class=\"line\">Digest: sha256:5807d78ba9c3892238a1eef2763c82f719d077b02a0c087122b816d276f0fbc4</span><br><span class=\"line\">Status: Downloaded newer image for mayankt/webserver:b</span><br><span class=\"line\">Pulling webserver-a (mayankt/webserver:a)...</span><br><span class=\"line\">a: Pulling from mayankt/webserver</span><br><span class=\"line\">3ac0c2aa6889: Already exists</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">f128b2a739b4: Already exists</span><br><span class=\"line\">1341f98ff817: Pull complete</span><br><span class=\"line\">Digest: sha256:921d4054855c335dcd48a83bd881fa9059fa003f62f1b29bbe4b3a40fc79cc9a</span><br><span class=\"line\">Status: Downloaded newer image for mayankt/webserver:a</span><br><span class=\"line\">Creating nitroide_webserver-b_1</span><br><span class=\"line\">Creating nitroide_nitro-ide_1</span><br><span class=\"line\">Creating nitroide_cpx_1</span><br><span class=\"line\">Creating nitroide_webserver-a_1</span><br></pre></td></tr></table></figure>\n<p>You can validate your desired containers are running by issuing a <code>docker ps</code> command to see all running containers.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS             </span><br><span class=\"line\">                                                                     NAMES</span><br><span class=\"line\">37892600b3d6        store/citrix/netscalercpx:12.0-41.16   &quot;/bin/sh -c &apos;bash ...&quot;   13 seconds ago      Up 10 seconds       22/tcp, 443/tcp, 1</span><br><span class=\"line\">61/udp, 0.0.0.0:10000-10050-&gt;10000-10050/tcp, 0.0.0.0:9080-&gt;80/tcp   nitroide_cpx_1</span><br><span class=\"line\">772b633440d7        mayankt/webserver:a                    &quot;/bin/sh -c &apos;nginx&apos;&quot;     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   </span><br><span class=\"line\">                                                                     nitroide_webserver-a_1</span><br><span class=\"line\">aeef73f08b84        mayankt/nitro-ide                      &quot;supervisord -c /e...&quot;   13 seconds ago      Up 11 seconds       3000/tcp, 0.0.0.0:</span><br><span class=\"line\">9090-&gt;80/tcp, 0.0.0.0:9091-&gt;8000/tcp                                 nitroide_nitro-ide_1</span><br><span class=\"line\">bb50c29a35c8        mayankt/webserver:b                    &quot;/bin/sh -c &apos;nginx&apos;&quot;     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   </span><br><span class=\"line\">                                                                     nitroide_webserver-b_1</span><br></pre></td></tr></table></figure>\n<h3>Step 2 : Access your IDE</h3>\n<p>Once all your containers are running successfully, navigate to your IDE’s web console. On your local machine, go to url <a href=\"http://localhost:9090\" target=\"_blank\" rel=\"noopener\">http://localhost:9090</a>.</p>\n<blockquote>\n<p>Please wait up to 60 seconds for the IDE and CPX to fully load before they are accessible via the web console. Usually services are available within 30 seconds of deployment.</p>\n</blockquote>\n<p>You should be greeted with Cloud9’s loading page and then ultimately the IDE editor pane. Within the side pane you should notice your <code>workspace</code> directory and within that directory you should see the <code>nitro-ide</code> repository on your docker host.</p>\n<p>You can select any file to open and edit it or to examine it. You even have access to the container’s CLI terminal in the bottom pane. In the container’s CLI pane within Cloud9 IDE, enter the following commands:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b cpx-101 https://github.com/Citrix-TechSpecialist/NetScalerNITRO.git</span><br></pre></td></tr></table></figure>\n<h3>Step 3 : Execute Script from IDE</h3>\n<p>A new directory will have been created <code>NetScalerNITRO</code> with the <code>nsAuto.py</code> python script that is pre-coded to configure the CPX to loadbalance webserver-a and webserver-b.</p>\n<p>In the bottom pane within the container’s CLI, enter the following commands to configure the CPX via NITRO scripted with Netscaler’s Python SDK. Desired state configuration is specified in the <code>nsAutoCfg.json</code> file with pre-seeded default values for our environment (i.e. backend webserver IP’s and CPX default username and pass along with its NSIP.)</p>\n<blockquote>\n<p>It is highly encouraged to open the <code>nsAuto.py</code> and <code>nsAutoCfg.json</code> file within the IDE to examine and learn from its contents and understand how the script is coded with NetScaler’s NITRO Python SDK.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd NetScalerNITRO</span><br><span class=\"line\">python nsAuto.py</span><br></pre></td></tr></table></figure>\n<p>You will see an output similar to:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Configuring NS</span><br><span class=\"line\">Starting to configure...</span><br><span class=\"line\">All done preforming configuration</span><br></pre></td></tr></table></figure>\n<p>This indicates that the CPX has been configured successfully. It is load balancing Webserver A and Webserver B on its port 10000, using it’s docker container IP in the sandbox docker network. Container port 10000 is mapped to host port 10000 so you can access your load balancer at <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<h3>Step 4 : Validate Configurations</h3>\n<p>To validate the configurations on the NetScaler CPX, enter the following commands on the Docker host to attach to the container’s bash terminal:</p>\n<p><code>docker exec -it nitroide_cpx_1 /bin/bash</code> and you will have entered into CPX’s CLI.</p>\n<p>Then enter in the following NetScaler CLI commands to view configured vservers on the ADC with the following command:</p>\n<p><code>cli_script.sh &quot;sh lb vservers&quot;</code> and you will see an output similar to the following for the configured vserver:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1)webserver (192.168.13.20:10000) - HTTPType: ADDRESS</span><br><span class=\"line\">State: UP</span><br><span class=\"line\">Last state change was at Fri Jul 14 02:02:23 2017</span><br><span class=\"line\">Time since last state change: 0 days, 01:30:54.410</span><br><span class=\"line\">Effective State: UP</span><br><span class=\"line\">Client Idle Timeout: 180 sec</span><br><span class=\"line\">Down state flush: ENABLED</span><br><span class=\"line\">Disable Primary Vserver On Down : DISABLED</span><br><span class=\"line\">Appflow logging: ENABLED</span><br><span class=\"line\">Port Rewrite : DISABLED</span><br><span class=\"line\">No. of Bound Services :  2 (Total)  2 (Active)</span><br><span class=\"line\">Configured Method: ROUNDROBINBackupMethod: NONE</span><br><span class=\"line\">Mode: IP</span><br><span class=\"line\">Persistence: NONE</span><br><span class=\"line\">Vserver IP and Port insertion: OFF</span><br><span class=\"line\">Push: DISABLEDPush VServer:</span><br><span class=\"line\">Push Multi Clients: NO</span><br><span class=\"line\">Push Label Rule: none</span><br><span class=\"line\">L2Conn: OFF</span><br><span class=\"line\">Skip Persistency: None</span><br><span class=\"line\">Listen Policy: NONE</span><br><span class=\"line\">IcmpResponse: PASSIVE</span><br><span class=\"line\">RHIstate: PASSIVE</span><br><span class=\"line\">New Service Startup Request Rate: 0 PER_SECOND, Increment Interval: 0</span><br><span class=\"line\">Mac mode Retain Vlan: DISABLED</span><br><span class=\"line\">DBS_LB: DISABLED</span><br><span class=\"line\">Process Local: DISABLED</span><br><span class=\"line\">Traffic Domain: 0</span><br><span class=\"line\">TROFS Persistence honored: ENABLED</span><br><span class=\"line\">Retain Connections on Cluster: NO</span><br></pre></td></tr></table></figure>\n<h3>Review</h3>\n<p>In this exercise we deployed a sandbox development environment with an IDE, NetScaler CPX, and 2 simple webservers using docker compose. We then logged into the IDE and cloned a repository with python code that will automatically configure the NetScaler CPX using the pre-defined input file <code>nsAutoCfg.json</code> that provides details on the desired configuration state of the CPX. We validated that the websites were being load balanced and saw the running load balancer configuration on the CPX.</p>\n<p>Here is an overview of the procedures above:</p>\n  <img src=\"/docker-101-mod3/docker-compose-up.gif\" title=\"docker compose up\">\n","site":{"data":{}},"hexoIncludeMarkdown":{"markdown":[]},"excerpt":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Module 3: Using Docker Compose</h1>\n<p>Let’s assume by now you are familiar with basic Docker commands such as <a href=\"https://docs.docker.com/engine/reference/run/#volume-shared-filesystems\" target=\"_blank\" rel=\"noopener\"><code>docker run</code></a>, <a href=\"https://docs.docker.com/engine/reference/commandline/ps/\" target=\"_blank\" rel=\"noopener\"><code>docker ps</code></a>, <a href=\"https://docs.docker.com/engine/reference/commandline/pull/\" target=\"_blank\" rel=\"noopener\"><code>docker pull</code></a>, <a href=\"https://docs.docker.com/engine/reference/commandline/rm/\" target=\"_blank\" rel=\"noopener\"><code>docker rm</code></a>, and the various parameter flags (such as <code>-v</code> for volume mounts) associated with some of these commands.</p>\n<p>It should also be obvious at this point that deploying docker containers at scale by hand with <code>docker run</code> commands can be very involved and, at time, too complicated with multiple lines of <code>docker ..</code> commands to deploy a large environment. Luckily, docker containers are not meant to be deployed via individual commands, rather they are often deployed to a desired state using various other tools that help automate and/or orchestrate microservices backed by docker containers. Some of these accompanying tools are provided below for reference.</p>","more":"<table>\n<thead>\n<tr>\n<th>Docker Tool</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><a href=\"https://kubernetes.io/\" target=\"_blank\" rel=\"noopener\">Kubernetes</a></td>\n<td>Google’s container orchestration and automation solution to schedule and maintain service state of docker containers.</td>\n</tr>\n<tr>\n<td><a href=\"https://mesosphere.com/why-mesos/?utm_source=adwords&amp;utm_medium=g&amp;utm_campaign=43843512431&amp;utm_term=mesos&amp;utm_content=196225818929&amp;gclid=CjwKEAjwtJzLBRC7z43vr63nr3wSJABjJDgJ_9xn3RWHnkH_nDjxQs1X8U6YgQ0drZPoOTfLv9-4hhoCqN3w_wcB\" target=\"_blank\" rel=\"noopener\">Mesos</a>/<a href=\"https://mesosphere.github.io/marathon/\" target=\"_blank\" rel=\"noopener\">Marathon</a></td>\n<td>Another Automation platform (Mesos) with an orchestration framework (Marathon) to ensure service state of docker containers.</td>\n</tr>\n<tr>\n<td><a href=\"http://rancher.com/\" target=\"_blank\" rel=\"noopener\">Rancher</a></td>\n<td>One of my favorites, complimentary to K8. Rancher is an opensource container management solution that makes it easy to deploy and manage containers in their own ‘Cattle environments’ and can even operate and manage other orchestration platforms like Kubernetes, Mesos/Marathon, and Docker Swarm.</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.docker.com/swarm/overview/\" target=\"_blank\" rel=\"noopener\">Docker Swarm</a></td>\n<td>Docker’s solution to automation and orchestration of clustered resources to provide a pool of Docker hosts into a single, virtual Docker host.</td>\n</tr>\n<tr>\n<td><a href=\"https://docs.docker.com/compose/\" target=\"_blank\" rel=\"noopener\">Docker Compose</a></td>\n<td>A automation tool for defining and running multi-container Docker applications. This tool is less sophisticated than the ones listed above and more simpler to use but with fewer features for larger deployments at scale.</td>\n</tr>\n</tbody>\n</table>\n<p><strong>In this module, we will be focusing on learning how to use Docker Compose to provision a self contained development environment based on a single input file that describes our desired state and configuration.</strong></p>\n<h2>Docker Compose</h2>\n<blockquote>\n<p>Source of description comes from <a href=\"https://docs.docker.com/compose/overview/\" target=\"_blank\" rel=\"noopener\">Docker’s documentation</a>.</p>\n</blockquote>\n<p>Compose is a tool for defining and running multi-container Docker applications. With Compose, you use a Compose file to configure your application’s services. Then, using a single command, you create and start all the services from your configuration.</p>\n<p>Using Compose is basically a three-step process.</p>\n<p><strong>Step 1</strong>: Define your container with a <code>Dockerfile</code> so it can be reproduced anywhere. Either have provide the <a href=\"https://docs.docker.com/compose/reference/build/\" target=\"_blank\" rel=\"noopener\">Dockerfile as an input</a> or have the defined container hosted in a <a href=\"https://docs.docker.com/registry/\" target=\"_blank\" rel=\"noopener\">docker registry</a> like <a href=\"hub.docker.com/\">docker hub</a>.</p>\n<p><strong>Step 2</strong>: Define the containers that make up your microservices in a <code>docker-compose.yml</code> file so it can be run together with other containers in an isolated environment. The <code>docker-compose.yml</code> basically consist of <code>key</code> : <code>value</code> pairs as per the <a href=\"https://github.com/Animosity/CraftIRC/wiki/Complete-idiot's-introduction-to-yaml\" target=\"_blank\" rel=\"noopener\">yaml syntax</a> describing the desired state of your services.</p>\n<p><strong>Step 3</strong>: Lastly, run the command <code>docker-compose up</code> and Compose will start and run your entire microservice based app as per the desired state.</p>\n<h2>Overview</h2>\n<p>In this module, we are going to automate the deployment of a simple, self contained, dockerized <a href=\"https://github.com/Citrix-TechSpecialist/nitro-ide\" target=\"_blank\" rel=\"noopener\">sandbox environment</a> to write scripts that issue <a href=\"http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html\" target=\"_blank\" rel=\"noopener\">NITRO</a> commands to your NetScaler ADCs. In this case we will be issuing commands to a <a href=\"microloadbalancer.com\">NetScaler CPX</a> that will be locally provisioned on your machine to load balance simple containerized websites. However, it should be noted that this tutorial can be translated to develop and issue commands against other <a href=\"https://www.citrix.com/products/netscaler-adc/platforms.html\" target=\"_blank\" rel=\"noopener\">NetScaler ADCs</a> as well if desired.</p>\n<p>The desired environment will have the following topology:</p>\n  <img src=\"/docker-101-mod3/topology.jpg\" title=\"Dev Box Topology\">\n<table>\n<thead>\n<tr>\n<th>Services</th>\n<th>Details</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Webserver A</strong></td>\n<td>Static containerized HTTP website</td>\n</tr>\n<tr>\n<td><strong>Webserver B</strong></td>\n<td>Static containerized HTTP website</td>\n</tr>\n<tr>\n<td><strong>NetScaler CPX</strong></td>\n<td>This will be the target NetScaler to send NITRO API calls to load balance webserver A and webserver B.</td>\n</tr>\n<tr>\n<td><strong>Cloud9 IDE</strong></td>\n<td>Web-based Interactive Developer Environment that allows for rapid scripting and coding through a web browser.</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>All the services above will be isolated in a dedicated <a href=\"https://docs.docker.com/engine/userguide/networking/\" target=\"_blank\" rel=\"noopener\">Docker Network</a>. Individual web interfaces that we will need direct external access to will have <a href=\"https://docs.docker.com/compose/compose-file/compose-file-v2/#ports\" target=\"_blank\" rel=\"noopener\">external ports mapped</a> to the container for access from the underlay network (basically your host’s LAN).</p>\n</blockquote>\n<hr>\n<h2>Exercise 1 : Create docker-compose.yaml</h2>\n<p>Instead of creating a <code>docker-compose.yml</code> file from scratch, we are going to copy one from another repository to get started. We will then examine the file and understand it’s anatomy before finally making edits to suite our environment needs.</p>\n<h3>Step 1</h3>\n<p>To get started, enter the following commands to clone a repository with a <code>docker-compose.yml</code> file already made for us. Navigate to the directory and view the contents with <code>nano</code>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Change directory to the workspace you want to clone the repository</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Clone the desired repository</span></span><br><span class=\"line\">sudo git <span class=\"built_in\">clone</span> https://github.com/Citrix-TechSpecialist/nitro-ide.git</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># enter the directory of the repository</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> nitro-ide</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># View the file contents of docker-compose.yml</span></span><br><span class=\"line\">nano docker-compose.yml</span><br></pre></td></tr></table></figure>\n<p>Here is a copy of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> file for reference. It is recommended you open it in another tab in your browser to follow along.</p>\n<p>Below are the desired services we want to configure and deploy.</p>\n<ol>\n<li><a href=\"https://hub.docker.com/r/mayankt/webserver/\" target=\"_blank\" rel=\"noopener\">Webserver A</a> that is a static website site</li>\n<li><a href=\"https://hub.docker.com/r/mayankt/webserver/\" target=\"_blank\" rel=\"noopener\">Webserver B</a> that is a different static website</li>\n<li><a href=\"https://c9.io/\" target=\"_blank\" rel=\"noopener\">Cloud9 IDE</a> which we will use to write code and execute python scripts to automate configuration of NetScaler CPX.</li>\n<li><a href=\"https://microloadbalancer.com\" target=\"_blank\" rel=\"noopener\">NetScaler CPX</a> a NetScaler in a docker container that share the same API as other NetScaler ADCs.</li>\n</ol>\n<h3>Explaining the docker-compose.yml File</h3>\n<p>Below are snippets of the <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\"><code>docker-compose.yaml</code></a>  with comments (<code>#</code>) per line with details of each <code>key</code> : <code>value</code> pairs describing the desired deployment.</p>\n<p><strong>Sandbox Network</strong></p>\n<p>With Docker you can define specific container networks. In this case we are creating a <a href=\"https://docs.docker.com/engine/userguide/networking/#bridge-networks\" target=\"_blank\" rel=\"noopener\">bridge network</a> specific to deploying only our desired containers to within a SDN boundary internal to the host.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">networks:                             # This defines that below are settings for docker networks</span><br><span class=\"line\">  sandbox:                            # Name of the network</span><br><span class=\"line\">    driver: bridge                    # The type of network driver to use</span><br><span class=\"line\">    ipam:                             # Details of the network and IP space</span><br><span class=\"line\">      config:                         # Configuration parameters</span><br><span class=\"line\">        - subnet: &quot;192.168.13.0/24&quot;   # The desired subnet of the docker network</span><br></pre></td></tr></table></figure>\n<p><strong>WebServer A / B</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webserver-a/b:                         # Service name</span><br><span class=\"line\">    image: &quot;mayankt/webserver:a&quot;       # Docker container image to use</span><br><span class=\"line\">    restart: always                    # Restart the service if it fails or the host reboots</span><br><span class=\"line\">    networks:                          # This describes the docker networks the containers will be part of</span><br><span class=\"line\">      sandbox:                         # Docker network&apos;s name</span><br><span class=\"line\">        ipv4_address: &quot;192.168.13.11&quot;  # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker&apos;s IPAM</span><br><span class=\"line\">    hostname: webserver-a              # Desired hostname of the container</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://docs.citrix.com/en-us/netscaler-cpx/12/deploy-using-docker-image-file.html\" target=\"_blank\" rel=\"noopener\"><strong>NetScaler CPX</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cpx:                                               # Service Name</span><br><span class=\"line\">  image: &quot;store/citrix/netscalercpx:12.0-41.16&quot;    # Docker container image to use from Citrix&apos; registry</span><br><span class=\"line\">  environment:\t\t\t\t\t\t\t\t\t                   # Environment Variables local to the container</span><br><span class=\"line\">    EULA: &quot;yes&quot;\t\t\t\t\t\t\t\t\t                   # same as &apos;export EULA=&quot;yes&quot;&apos; as a pre-req for CPX to work</span><br><span class=\"line\">  restart: always                                  # Restart the service if it fails or the host reboots</span><br><span class=\"line\">  cap_add:                                         # Add specific container kernel capabilities https://docs.docker.com/engine/security/security/#linux-kernel-capabilities</span><br><span class=\"line\">    - NET_ADMIN                                    # Perform various network-related operations https://linux.die.net/man/7/capabilities</span><br><span class=\"line\">  ulimits                                          # Override the default (resource) ulimits for a container</span><br><span class=\"line\">    core: -1                                       # Use unlimited CPU, up to the amount available on the host system.</span><br><span class=\"line\">  networks:                                        # This describes the docker networks the containers will be part of</span><br><span class=\"line\">    sandbox:                                       # Docker network&apos;s name</span><br><span class=\"line\">      ipv4_address: &quot;192.168.13.20&quot;                # Static IP address of this service/container. You can leave this key:value out and to obtain an IP from Docker&apos;s IPAM</span><br><span class=\"line\">  ports:                                           # Exposed ports mapped to the host from the container.</span><br><span class=\"line\">    - &quot;10000-10050:10000-10050&quot;\t\t\t\t\t</span><br><span class=\"line\">    - &quot;9080:80&quot;</span><br><span class=\"line\">  hostname: ns-adc                                 # Desired hostname of the container</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://aws.amazon.com/cloud9/\" target=\"_blank\" rel=\"noopener\"><strong>Cloud9 IDE</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nitro-ide:                          # Service Name</span><br><span class=\"line\">  image: &quot;mayankt/nitro-ide&quot;        # Docker container image to use from Citrix&apos; registry</span><br><span class=\"line\">  restart: always                   # Restart the service if it fails or the host reboots</span><br><span class=\"line\">  dns: 8.8.8.8                      # Specific DNS server to use for host name resolution from within the container</span><br><span class=\"line\">  networks:                         # This describes the docker networks the containers will be part of</span><br><span class=\"line\">    sandbox:                        # Docker network&apos;s name</span><br><span class=\"line\">      ipv4_address: &quot;192.168.13.10&quot; # Static IP address of this service/</span><br><span class=\"line\">  ports:                            # Exposed ports mapped to the host from the container.</span><br><span class=\"line\">    - &quot;9090:80&quot;</span><br><span class=\"line\">    - &quot;9091:8000&quot;</span><br><span class=\"line\">  links:                            # Link to containers in another service given service name and/or a link alias (&quot;SERVICE:ALIAS&quot;). &quot;ping web-a&quot; will ping the webserver-a service from within the container.</span><br><span class=\"line\">    - &quot;cpx&quot;</span><br><span class=\"line\">    - &quot;webserver-a:web-a&quot;</span><br><span class=\"line\">    - &quot;webserver-b:web-b&quot;</span><br><span class=\"line\">  volumes:                          # Volume mounts local to the host mapped to a directory local to the container with read/write access (rw)</span><br><span class=\"line\">      - $&#123;DATA_DIR&#125;:/workspace:rw      </span><br><span class=\"line\">  hostname: nitro-ide               # Desired hostname of the container</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Note you may have to uncomment the <code>volumes</code> section to mount volumes in the docker file that is pulled from the repository. Use <code>nano</code> to remove the <code>#</code> from the <code>volumes:</code> block.</p>\n</blockquote>\n<h3>Step 2</h3>\n<p>Set the environmental variable <code>DATA_DIR</code> to <code>/data</code> on the docker host. This environment variable will substitute the value <code>/data</code> into the docker compose file when we provision our containers. Type the following on your docker host:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export DATA_DIR=&quot;/data&quot;`</span><br></pre></td></tr></table></figure>\n<p>Verify that the environmental variable was set successfully by typing the following command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo $DATA_DIR</span><br></pre></td></tr></table></figure>\n<p>It should return the <code>/data</code> directory path.</p>\n<h3>Review</h3>\n<p>In this module we clones a repository with our desired compose file. We explored what constitutes a <code>docker-compose.yml</code> file and what the various parameters mean. We set the value <code>/data</code> for a placeholder in the compose file that took in an environment variable to specify which local directory will be mapped to our IDE’s local workspace <code>/workspace</code> so we can share data from host to container.</p>\n<p>Here is an overview of configuration steps:</p>\n  <img src=\"/docker-101-mod3/docker-compose.gif\" title=\"docker-compose up -d\">\n<hr>\n<h2>Exercise 2 : Compose an Environment</h2>\n<p>Once you have your <a href=\"/_code/docker-101/docker-compose.yaml\" download=\"docker-compose.yaml\">docker-compose.yaml</a> set, you can move forward with provisioning your environment.</p>\n<h3>Step 1 : Provision an Environment</h3>\n<p>In the <code>/data/nitro-ide</code> directory, enter the following commands:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Navigate to the repository local to your host</span><br><span class=\"line\">cd /data/nitro-ide</span><br><span class=\"line\"></span><br><span class=\"line\"># Issue the docker compose command to provision your environment</span><br><span class=\"line\">docker-compose up -d</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The <code>-d</code> in the <a href=\"https://docs.docker.com/compose/reference/up/\" target=\"_blank\" rel=\"noopener\"><code>docker-compose up -d</code></a> specifies that containers run in the background in detached mode.</p>\n</blockquote>\n<p>You should observe an output similar to the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pulling cpx (store/citrix/netscalercpx:12.0-41.16)...</span><br><span class=\"line\">12.0-41.16: Pulling from store/citrix/netscalercpx</span><br><span class=\"line\">4e1f679e8ab4: Pull complete</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">588f5003e10f: Pull complete</span><br><span class=\"line\">Digest: sha256:31a65cfa38833c747721c6fbc142faec6051e5f7b567d8b212d912b69b4f1ebe</span><br><span class=\"line\">Status: Downloaded newer image for store/citrix/netscalercpx:12.0-41.16</span><br><span class=\"line\">Pulling nitro-ide (mayankt/nitro-ide:latest)...</span><br><span class=\"line\">latest: Pulling from mayankt/nitro-ide</span><br><span class=\"line\">a3ed95caeb02: Pull complete</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">9581fa7fd579: Pull complete</span><br><span class=\"line\">Digest: sha256:53c464876633e95f8e11ea821c50add0ff8e00a70c5aacd65f465d2d3045d8d3</span><br><span class=\"line\">Status: Downloaded newer image for mayankt/nitro-ide:latest</span><br><span class=\"line\">Pulling webserver-b (mayankt/webserver:b)...</span><br><span class=\"line\">b: Pulling from mayankt/webserver</span><br><span class=\"line\">3ac0c2aa6889: Pull complete</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">4484f1613730: Pull complete</span><br><span class=\"line\">Digest: sha256:5807d78ba9c3892238a1eef2763c82f719d077b02a0c087122b816d276f0fbc4</span><br><span class=\"line\">Status: Downloaded newer image for mayankt/webserver:b</span><br><span class=\"line\">Pulling webserver-a (mayankt/webserver:a)...</span><br><span class=\"line\">a: Pulling from mayankt/webserver</span><br><span class=\"line\">3ac0c2aa6889: Already exists</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">..</span><br><span class=\"line\">f128b2a739b4: Already exists</span><br><span class=\"line\">1341f98ff817: Pull complete</span><br><span class=\"line\">Digest: sha256:921d4054855c335dcd48a83bd881fa9059fa003f62f1b29bbe4b3a40fc79cc9a</span><br><span class=\"line\">Status: Downloaded newer image for mayankt/webserver:a</span><br><span class=\"line\">Creating nitroide_webserver-b_1</span><br><span class=\"line\">Creating nitroide_nitro-ide_1</span><br><span class=\"line\">Creating nitroide_cpx_1</span><br><span class=\"line\">Creating nitroide_webserver-a_1</span><br></pre></td></tr></table></figure>\n<p>You can validate your desired containers are running by issuing a <code>docker ps</code> command to see all running containers.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CONTAINER ID        IMAGE                                  COMMAND                  CREATED             STATUS              PORTS             </span><br><span class=\"line\">                                                                     NAMES</span><br><span class=\"line\">37892600b3d6        store/citrix/netscalercpx:12.0-41.16   &quot;/bin/sh -c &apos;bash ...&quot;   13 seconds ago      Up 10 seconds       22/tcp, 443/tcp, 1</span><br><span class=\"line\">61/udp, 0.0.0.0:10000-10050-&gt;10000-10050/tcp, 0.0.0.0:9080-&gt;80/tcp   nitroide_cpx_1</span><br><span class=\"line\">772b633440d7        mayankt/webserver:a                    &quot;/bin/sh -c &apos;nginx&apos;&quot;     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   </span><br><span class=\"line\">                                                                     nitroide_webserver-a_1</span><br><span class=\"line\">aeef73f08b84        mayankt/nitro-ide                      &quot;supervisord -c /e...&quot;   13 seconds ago      Up 11 seconds       3000/tcp, 0.0.0.0:</span><br><span class=\"line\">9090-&gt;80/tcp, 0.0.0.0:9091-&gt;8000/tcp                                 nitroide_nitro-ide_1</span><br><span class=\"line\">bb50c29a35c8        mayankt/webserver:b                    &quot;/bin/sh -c &apos;nginx&apos;&quot;     13 seconds ago      Up 10 seconds       80/tcp, 443/tcp   </span><br><span class=\"line\">                                                                     nitroide_webserver-b_1</span><br></pre></td></tr></table></figure>\n<h3>Step 2 : Access your IDE</h3>\n<p>Once all your containers are running successfully, navigate to your IDE’s web console. On your local machine, go to url <a href=\"http://localhost:9090\" target=\"_blank\" rel=\"noopener\">http://localhost:9090</a>.</p>\n<blockquote>\n<p>Please wait up to 60 seconds for the IDE and CPX to fully load before they are accessible via the web console. Usually services are available within 30 seconds of deployment.</p>\n</blockquote>\n<p>You should be greeted with Cloud9’s loading page and then ultimately the IDE editor pane. Within the side pane you should notice your <code>workspace</code> directory and within that directory you should see the <code>nitro-ide</code> repository on your docker host.</p>\n<p>You can select any file to open and edit it or to examine it. You even have access to the container’s CLI terminal in the bottom pane. In the container’s CLI pane within Cloud9 IDE, enter the following commands:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone -b cpx-101 https://github.com/Citrix-TechSpecialist/NetScalerNITRO.git</span><br></pre></td></tr></table></figure>\n<h3>Step 3 : Execute Script from IDE</h3>\n<p>A new directory will have been created <code>NetScalerNITRO</code> with the <code>nsAuto.py</code> python script that is pre-coded to configure the CPX to loadbalance webserver-a and webserver-b.</p>\n<p>In the bottom pane within the container’s CLI, enter the following commands to configure the CPX via NITRO scripted with Netscaler’s Python SDK. Desired state configuration is specified in the <code>nsAutoCfg.json</code> file with pre-seeded default values for our environment (i.e. backend webserver IP’s and CPX default username and pass along with its NSIP.)</p>\n<blockquote>\n<p>It is highly encouraged to open the <code>nsAuto.py</code> and <code>nsAutoCfg.json</code> file within the IDE to examine and learn from its contents and understand how the script is coded with NetScaler’s NITRO Python SDK.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd NetScalerNITRO</span><br><span class=\"line\">python nsAuto.py</span><br></pre></td></tr></table></figure>\n<p>You will see an output similar to:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Configuring NS</span><br><span class=\"line\">Starting to configure...</span><br><span class=\"line\">All done preforming configuration</span><br></pre></td></tr></table></figure>\n<p>This indicates that the CPX has been configured successfully. It is load balancing Webserver A and Webserver B on its port 10000, using it’s docker container IP in the sandbox docker network. Container port 10000 is mapped to host port 10000 so you can access your load balancer at <a href=\"http://localhost:10000\" target=\"_blank\" rel=\"noopener\">http://localhost:10000</a>.</p>\n<h3>Step 4 : Validate Configurations</h3>\n<p>To validate the configurations on the NetScaler CPX, enter the following commands on the Docker host to attach to the container’s bash terminal:</p>\n<p><code>docker exec -it nitroide_cpx_1 /bin/bash</code> and you will have entered into CPX’s CLI.</p>\n<p>Then enter in the following NetScaler CLI commands to view configured vservers on the ADC with the following command:</p>\n<p><code>cli_script.sh &quot;sh lb vservers&quot;</code> and you will see an output similar to the following for the configured vserver:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1)webserver (192.168.13.20:10000) - HTTPType: ADDRESS</span><br><span class=\"line\">State: UP</span><br><span class=\"line\">Last state change was at Fri Jul 14 02:02:23 2017</span><br><span class=\"line\">Time since last state change: 0 days, 01:30:54.410</span><br><span class=\"line\">Effective State: UP</span><br><span class=\"line\">Client Idle Timeout: 180 sec</span><br><span class=\"line\">Down state flush: ENABLED</span><br><span class=\"line\">Disable Primary Vserver On Down : DISABLED</span><br><span class=\"line\">Appflow logging: ENABLED</span><br><span class=\"line\">Port Rewrite : DISABLED</span><br><span class=\"line\">No. of Bound Services :  2 (Total)  2 (Active)</span><br><span class=\"line\">Configured Method: ROUNDROBINBackupMethod: NONE</span><br><span class=\"line\">Mode: IP</span><br><span class=\"line\">Persistence: NONE</span><br><span class=\"line\">Vserver IP and Port insertion: OFF</span><br><span class=\"line\">Push: DISABLEDPush VServer:</span><br><span class=\"line\">Push Multi Clients: NO</span><br><span class=\"line\">Push Label Rule: none</span><br><span class=\"line\">L2Conn: OFF</span><br><span class=\"line\">Skip Persistency: None</span><br><span class=\"line\">Listen Policy: NONE</span><br><span class=\"line\">IcmpResponse: PASSIVE</span><br><span class=\"line\">RHIstate: PASSIVE</span><br><span class=\"line\">New Service Startup Request Rate: 0 PER_SECOND, Increment Interval: 0</span><br><span class=\"line\">Mac mode Retain Vlan: DISABLED</span><br><span class=\"line\">DBS_LB: DISABLED</span><br><span class=\"line\">Process Local: DISABLED</span><br><span class=\"line\">Traffic Domain: 0</span><br><span class=\"line\">TROFS Persistence honored: ENABLED</span><br><span class=\"line\">Retain Connections on Cluster: NO</span><br></pre></td></tr></table></figure>\n<h3>Review</h3>\n<p>In this exercise we deployed a sandbox development environment with an IDE, NetScaler CPX, and 2 simple webservers using docker compose. We then logged into the IDE and cloned a repository with python code that will automatically configure the NetScaler CPX using the pre-defined input file <code>nsAutoCfg.json</code> that provides details on the desired configuration state of the CPX. We validated that the websites were being load balanced and saw the running load balancer configuration on the CPX.</p>\n<p>Here is an overview of the procedures above:</p>\n  <img src=\"/docker-101-mod3/docker-compose-up.gif\" title=\"docker compose up\">"},{"title":"Hands on with Docker","date":"2017-12-15T01:28:29.000Z","show":true,"_content":"\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n\n# Introduction\n\nI figured I'd start off my first post on a topic I am deeply passionate about : [**Docker containers**](https://www.docker.com/what-container)! In this tutorial, we are going to gain hands on experience and learn the basics docker containers are (how to run them, configure them, and consume them), docker images (how to use them and how to build them), docker commands, and finally learn how to automate the deployment of a simple 'containerized environment' with multiple 'services'.\n\n<!-- more -->\n\nThe end result will be a self contained dockerized [sandbox environment / IDE](https://github.com/Citrix-TechSpecialist/nitro-ide/tree/0206630bd6903887d599613a42dd65da550cc37e) to develop scripts and to issue them via [NITRO REST API](http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html) commands to your NetScaler ADCs. This is just one of **many use cases** to showcase container 'orchestration' to a desired state via simple YAML files. But before we begin, we need a brief introduction on 'containers' and how Docker works under the hood.  This introduction is meant to be short intentionally because the point of the tutorial below is more focused on getting \"hands on experience\" rather than \"delving into theory\".\n\n# Tutorial Contents\n\n  * [**Module 0**: Install Docker Locally](https://docs.docker.com/engine/installation/)\n  * [**Module 1**: Introduction to Docker Images and Containers](/docker-101-mod1)\n  \t* *Exercise 1*: Pulling Docker Images\n  \t* *Exercise 2*: Running a Docker Container\n  * [**Module 2**: Introduction to Docker Files](/docker-101-mod2)\n    * *Dockerfiles* \n  \t* *Exercise 1*: Write a Dockerfile\n  \t* *Exercise 2*: Run another Docker Container\n  * [**Module 3**: Introduction to Docker Compose](/docker-101-mod3)\n    * *Exercise 1*: Create a `docker-compose.yaml` file\n  \t* *Exercise 2*: Compose an Environment\n\n\n# Brief Technology Overview\n\n> Source of the content below comes from an article published in [InfoWold](http://www.infoworld.com/article/3204171/linux/what-is-docker-linux-containers-explained.html)\n\n[Docker containers](https://blog.docker.com/2016/05/docker-101-getting-to-know-docker/) are self-contained execution environments—with their own, isolated CPU, memory, block I/O, and network resources—that share the kernel of the host operating system. The result is **something that feels like a virtual machine, but sheds all the weight and startup overhead of a guest operating system.** \n\nTo understand containers, we have to start with Linux [cgroups](https://sysadmincasts.com/episodes/14-introduction-to-linux-control-groups-cgroups) and [namespaces](http://blogs.igalia.com/dpino/2016/04/10/network-namespaces/), the Linux kernel features that create the walls between containers and other processes running on the host. Linux namespaces, originally developed by IBM, wrap a set of system resources and present them to a process to make it look like they are dedicated to that process.\n\n**In short:** \n\n  * **Namespaces** :  Limits what the running process can see. I.E. processes can have their own view of the system’s resources.\n  * **cgroups** :  Metering and limiting mechanism, they control how much of a system resource (CPU, memory) processes can use.\n\nIn comparison to virtual machines, containers feel and act like independent operating system environments, but are actually layered on top of an existing OS similar to how a VM would be on top of a hypervisor. A visual below is provided for contextual aid in comparison with traditional VM architecture vs a docker containerized architecture. \n\n  {% asset_img containers-visual.png Containers vs Virtual Machines %}\n\n# Pre-requisites \n\n  * [Install Docker](https://docs.docker.com/engine/installation/)\n  \t* You must install Docker in your local environment to do this tutorial. Follow the instructions in the link provided to install Docker on your operating system. \n\n> **Note**: You can also find this tutorial directly on GitHub where I've posted an older version of this lab [here](https://github.com/Citrix-TechSpecialist/Docker-101) within the \"Docker-101\" repository of the [@Citrix-TechSpecialist](https://github.com/Citrix-TechSpecialist) organization. ","source":"_posts/docker-101.md","raw":"---\ntitle: Hands on with Docker\ntag:\n - [docker]\n - [docker 101]\n - [containers]\ncategory:\n  - [tutorials]\n  - [docker]\ndate: 2017-12-14 17:28:29\nshow: true\n---\n\n[Module 0](https://docs.docker.com/engine/installation/) | [Module 1](/docker-101-mod1) | [Module 2](/docker-101-mod2) | [Module 3](/docker-101-mod3)\n:---: | :---: | :---: | :---:\n\n\n# Introduction\n\nI figured I'd start off my first post on a topic I am deeply passionate about : [**Docker containers**](https://www.docker.com/what-container)! In this tutorial, we are going to gain hands on experience and learn the basics docker containers are (how to run them, configure them, and consume them), docker images (how to use them and how to build them), docker commands, and finally learn how to automate the deployment of a simple 'containerized environment' with multiple 'services'.\n\n<!-- more -->\n\nThe end result will be a self contained dockerized [sandbox environment / IDE](https://github.com/Citrix-TechSpecialist/nitro-ide/tree/0206630bd6903887d599613a42dd65da550cc37e) to develop scripts and to issue them via [NITRO REST API](http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html) commands to your NetScaler ADCs. This is just one of **many use cases** to showcase container 'orchestration' to a desired state via simple YAML files. But before we begin, we need a brief introduction on 'containers' and how Docker works under the hood.  This introduction is meant to be short intentionally because the point of the tutorial below is more focused on getting \"hands on experience\" rather than \"delving into theory\".\n\n# Tutorial Contents\n\n  * [**Module 0**: Install Docker Locally](https://docs.docker.com/engine/installation/)\n  * [**Module 1**: Introduction to Docker Images and Containers](/docker-101-mod1)\n  \t* *Exercise 1*: Pulling Docker Images\n  \t* *Exercise 2*: Running a Docker Container\n  * [**Module 2**: Introduction to Docker Files](/docker-101-mod2)\n    * *Dockerfiles* \n  \t* *Exercise 1*: Write a Dockerfile\n  \t* *Exercise 2*: Run another Docker Container\n  * [**Module 3**: Introduction to Docker Compose](/docker-101-mod3)\n    * *Exercise 1*: Create a `docker-compose.yaml` file\n  \t* *Exercise 2*: Compose an Environment\n\n\n# Brief Technology Overview\n\n> Source of the content below comes from an article published in [InfoWold](http://www.infoworld.com/article/3204171/linux/what-is-docker-linux-containers-explained.html)\n\n[Docker containers](https://blog.docker.com/2016/05/docker-101-getting-to-know-docker/) are self-contained execution environments—with their own, isolated CPU, memory, block I/O, and network resources—that share the kernel of the host operating system. The result is **something that feels like a virtual machine, but sheds all the weight and startup overhead of a guest operating system.** \n\nTo understand containers, we have to start with Linux [cgroups](https://sysadmincasts.com/episodes/14-introduction-to-linux-control-groups-cgroups) and [namespaces](http://blogs.igalia.com/dpino/2016/04/10/network-namespaces/), the Linux kernel features that create the walls between containers and other processes running on the host. Linux namespaces, originally developed by IBM, wrap a set of system resources and present them to a process to make it look like they are dedicated to that process.\n\n**In short:** \n\n  * **Namespaces** :  Limits what the running process can see. I.E. processes can have their own view of the system’s resources.\n  * **cgroups** :  Metering and limiting mechanism, they control how much of a system resource (CPU, memory) processes can use.\n\nIn comparison to virtual machines, containers feel and act like independent operating system environments, but are actually layered on top of an existing OS similar to how a VM would be on top of a hypervisor. A visual below is provided for contextual aid in comparison with traditional VM architecture vs a docker containerized architecture. \n\n  {% asset_img containers-visual.png Containers vs Virtual Machines %}\n\n# Pre-requisites \n\n  * [Install Docker](https://docs.docker.com/engine/installation/)\n  \t* You must install Docker in your local environment to do this tutorial. Follow the instructions in the link provided to install Docker on your operating system. \n\n> **Note**: You can also find this tutorial directly on GitHub where I've posted an older version of this lab [here](https://github.com/Citrix-TechSpecialist/Docker-101) within the \"Docker-101\" repository of the [@Citrix-TechSpecialist](https://github.com/Citrix-TechSpecialist) organization. ","slug":"docker-101","published":1,"updated":"2017-12-15T21:04:18.000Z","_id":"cjb8926jt000fpbmllm3z48xv","comments":1,"layout":"post","photos":[],"link":"","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Introduction</h1>\n<p>I figured I’d start off my first post on a topic I am deeply passionate about : <a href=\"https://www.docker.com/what-container\" target=\"_blank\" rel=\"noopener\"><strong>Docker containers</strong></a>! In this tutorial, we are going to gain hands on experience and learn the basics docker containers are (how to run them, configure them, and consume them), docker images (how to use them and how to build them), docker commands, and finally learn how to automate the deployment of a simple ‘containerized environment’ with multiple ‘services’.</p>\n<a id=\"more\"></a>\n<p>The end result will be a self contained dockerized <a href=\"https://github.com/Citrix-TechSpecialist/nitro-ide/tree/0206630bd6903887d599613a42dd65da550cc37e\" target=\"_blank\" rel=\"noopener\">sandbox environment / IDE</a> to develop scripts and to issue them via <a href=\"http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html\" target=\"_blank\" rel=\"noopener\">NITRO REST API</a> commands to your NetScaler ADCs. This is just one of <strong>many use cases</strong> to showcase container ‘orchestration’ to a desired state via simple YAML files. But before we begin, we need a brief introduction on ‘containers’ and how Docker works under the hood.  This introduction is meant to be short intentionally because the point of the tutorial below is more focused on getting “hands on experience” rather than “delving into theory”.</p>\n<h1>Tutorial Contents</h1>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\"><strong>Module 0</strong>: Install Docker Locally</a></li>\n<li><a href=\"/docker-101-mod1\"><strong>Module 1</strong>: Introduction to Docker Images and Containers</a>\n<ul>\n<li><em>Exercise 1</em>: Pulling Docker Images</li>\n<li><em>Exercise 2</em>: Running a Docker Container</li>\n</ul>\n</li>\n<li><a href=\"/docker-101-mod2\"><strong>Module 2</strong>: Introduction to Docker Files</a>\n<ul>\n<li><em>Dockerfiles</em></li>\n<li><em>Exercise 1</em>: Write a Dockerfile</li>\n<li><em>Exercise 2</em>: Run another Docker Container</li>\n</ul>\n</li>\n<li><a href=\"/docker-101-mod3\"><strong>Module 3</strong>: Introduction to Docker Compose</a>\n<ul>\n<li><em>Exercise 1</em>: Create a <code>docker-compose.yaml</code> file</li>\n<li><em>Exercise 2</em>: Compose an Environment</li>\n</ul>\n</li>\n</ul>\n<h1>Brief Technology Overview</h1>\n<blockquote>\n<p>Source of the content below comes from an article published in <a href=\"http://www.infoworld.com/article/3204171/linux/what-is-docker-linux-containers-explained.html\" target=\"_blank\" rel=\"noopener\">InfoWold</a></p>\n</blockquote>\n<p><a href=\"https://blog.docker.com/2016/05/docker-101-getting-to-know-docker/\" target=\"_blank\" rel=\"noopener\">Docker containers</a> are self-contained execution environments—with their own, isolated CPU, memory, block I/O, and network resources—that share the kernel of the host operating system. The result is <strong>something that feels like a virtual machine, but sheds all the weight and startup overhead of a guest operating system.</strong></p>\n<p>To understand containers, we have to start with Linux <a href=\"https://sysadmincasts.com/episodes/14-introduction-to-linux-control-groups-cgroups\" target=\"_blank\" rel=\"noopener\">cgroups</a> and <a href=\"http://blogs.igalia.com/dpino/2016/04/10/network-namespaces/\" target=\"_blank\" rel=\"noopener\">namespaces</a>, the Linux kernel features that create the walls between containers and other processes running on the host. Linux namespaces, originally developed by IBM, wrap a set of system resources and present them to a process to make it look like they are dedicated to that process.</p>\n<p><strong>In short:</strong></p>\n<ul>\n<li><strong>Namespaces</strong> :  Limits what the running process can see. I.E. processes can have their own view of the system’s resources.</li>\n<li><strong>cgroups</strong> :  Metering and limiting mechanism, they control how much of a system resource (CPU, memory) processes can use.</li>\n</ul>\n<p>In comparison to virtual machines, containers feel and act like independent operating system environments, but are actually layered on top of an existing OS similar to how a VM would be on top of a hypervisor. A visual below is provided for contextual aid in comparison with traditional VM architecture vs a docker containerized architecture.</p>\n  <img src=\"/docker-101/containers-visual.png\" title=\"Containers vs Virtual Machines\">\n<h1>Pre-requisites</h1>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Install Docker</a>\n<ul>\n<li>You must install Docker in your local environment to do this tutorial. Follow the instructions in the link provided to install Docker on your operating system.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Note</strong>: You can also find this tutorial directly on GitHub where I’ve posted an older version of this lab <a href=\"https://github.com/Citrix-TechSpecialist/Docker-101\" target=\"_blank\" rel=\"noopener\">here</a> within the “Docker-101” repository of the <a href=\"https://github.com/Citrix-TechSpecialist\" target=\"_blank\" rel=\"noopener\">@Citrix-TechSpecialist</a> organization.</p>\n</blockquote>\n","site":{"data":{}},"hexoIncludeMarkdown":{"markdown":[]},"excerpt":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Module 0</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod1\">Module 1</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod2\">Module 2</a></th>\n<th style=\"text-align:center\"><a href=\"/docker-101-mod3\">Module 3</a></th>\n</tr>\n</thead>\n<tbody></tbody>\n</table>\n<h1>Introduction</h1>\n<p>I figured I’d start off my first post on a topic I am deeply passionate about : <a href=\"https://www.docker.com/what-container\" target=\"_blank\" rel=\"noopener\"><strong>Docker containers</strong></a>! In this tutorial, we are going to gain hands on experience and learn the basics docker containers are (how to run them, configure them, and consume them), docker images (how to use them and how to build them), docker commands, and finally learn how to automate the deployment of a simple ‘containerized environment’ with multiple ‘services’.</p>","more":"<p>The end result will be a self contained dockerized <a href=\"https://github.com/Citrix-TechSpecialist/nitro-ide/tree/0206630bd6903887d599613a42dd65da550cc37e\" target=\"_blank\" rel=\"noopener\">sandbox environment / IDE</a> to develop scripts and to issue them via <a href=\"http://docs.citrix.com/ja-jp/netscaler/11/nitro-api.html\" target=\"_blank\" rel=\"noopener\">NITRO REST API</a> commands to your NetScaler ADCs. This is just one of <strong>many use cases</strong> to showcase container ‘orchestration’ to a desired state via simple YAML files. But before we begin, we need a brief introduction on ‘containers’ and how Docker works under the hood.  This introduction is meant to be short intentionally because the point of the tutorial below is more focused on getting “hands on experience” rather than “delving into theory”.</p>\n<h1>Tutorial Contents</h1>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\"><strong>Module 0</strong>: Install Docker Locally</a></li>\n<li><a href=\"/docker-101-mod1\"><strong>Module 1</strong>: Introduction to Docker Images and Containers</a>\n<ul>\n<li><em>Exercise 1</em>: Pulling Docker Images</li>\n<li><em>Exercise 2</em>: Running a Docker Container</li>\n</ul>\n</li>\n<li><a href=\"/docker-101-mod2\"><strong>Module 2</strong>: Introduction to Docker Files</a>\n<ul>\n<li><em>Dockerfiles</em></li>\n<li><em>Exercise 1</em>: Write a Dockerfile</li>\n<li><em>Exercise 2</em>: Run another Docker Container</li>\n</ul>\n</li>\n<li><a href=\"/docker-101-mod3\"><strong>Module 3</strong>: Introduction to Docker Compose</a>\n<ul>\n<li><em>Exercise 1</em>: Create a <code>docker-compose.yaml</code> file</li>\n<li><em>Exercise 2</em>: Compose an Environment</li>\n</ul>\n</li>\n</ul>\n<h1>Brief Technology Overview</h1>\n<blockquote>\n<p>Source of the content below comes from an article published in <a href=\"http://www.infoworld.com/article/3204171/linux/what-is-docker-linux-containers-explained.html\" target=\"_blank\" rel=\"noopener\">InfoWold</a></p>\n</blockquote>\n<p><a href=\"https://blog.docker.com/2016/05/docker-101-getting-to-know-docker/\" target=\"_blank\" rel=\"noopener\">Docker containers</a> are self-contained execution environments—with their own, isolated CPU, memory, block I/O, and network resources—that share the kernel of the host operating system. The result is <strong>something that feels like a virtual machine, but sheds all the weight and startup overhead of a guest operating system.</strong></p>\n<p>To understand containers, we have to start with Linux <a href=\"https://sysadmincasts.com/episodes/14-introduction-to-linux-control-groups-cgroups\" target=\"_blank\" rel=\"noopener\">cgroups</a> and <a href=\"http://blogs.igalia.com/dpino/2016/04/10/network-namespaces/\" target=\"_blank\" rel=\"noopener\">namespaces</a>, the Linux kernel features that create the walls between containers and other processes running on the host. Linux namespaces, originally developed by IBM, wrap a set of system resources and present them to a process to make it look like they are dedicated to that process.</p>\n<p><strong>In short:</strong></p>\n<ul>\n<li><strong>Namespaces</strong> :  Limits what the running process can see. I.E. processes can have their own view of the system’s resources.</li>\n<li><strong>cgroups</strong> :  Metering and limiting mechanism, they control how much of a system resource (CPU, memory) processes can use.</li>\n</ul>\n<p>In comparison to virtual machines, containers feel and act like independent operating system environments, but are actually layered on top of an existing OS similar to how a VM would be on top of a hypervisor. A visual below is provided for contextual aid in comparison with traditional VM architecture vs a docker containerized architecture.</p>\n  <img src=\"/docker-101/containers-visual.png\" title=\"Containers vs Virtual Machines\">\n<h1>Pre-requisites</h1>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/installation/\" target=\"_blank\" rel=\"noopener\">Install Docker</a>\n<ul>\n<li>You must install Docker in your local environment to do this tutorial. Follow the instructions in the link provided to install Docker on your operating system.</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p><strong>Note</strong>: You can also find this tutorial directly on GitHub where I’ve posted an older version of this lab <a href=\"https://github.com/Citrix-TechSpecialist/Docker-101\" target=\"_blank\" rel=\"noopener\">here</a> within the “Docker-101” repository of the <a href=\"https://github.com/Citrix-TechSpecialist\" target=\"_blank\" rel=\"noopener\">@Citrix-TechSpecialist</a> organization.</p>\n</blockquote>"}],"PostAsset":[{"_id":"source/_posts/docker-101-mod2/cpx-blog-2-footer.png","slug":"cpx-blog-2-footer.png","post":"cjb8926jl000bpbmlb6textz6","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod2/cpx-blog-1-footer.png","slug":"cpx-blog-1-footer.png","post":"cjb8926jl000bpbmlb6textz6","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod1/docker-pull.gif","slug":"docker-pull.gif","post":"cjb8926h70000pbml7eu444gi","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod1/docker-run.gif","slug":"docker-run.gif","post":"cjb8926h70000pbml7eu444gi","modified":0,"renderable":0},{"_id":"source/_posts/docker-101/containers-visual.png","slug":"containers-visual.png","post":"cjb8926jt000fpbmllm3z48xv","modified":0,"renderable":0},{"_id":"source/_posts/docker-101/docker-images.png","slug":"docker-images.png","post":"cjb8926jt000fpbmllm3z48xv","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod3/docker-compose-up.gif","slug":"docker-compose-up.gif","post":"cjb8926jn000dpbml5l0x8ysv","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod3/docker-compose.gif","slug":"docker-compose.gif","post":"cjb8926jn000dpbml5l0x8ysv","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod3/topology.jpg","slug":"topology.jpg","post":"cjb8926jn000dpbml5l0x8ysv","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod2/docker-build.gif","slug":"docker-build.gif","post":"cjb8926jl000bpbmlb6textz6","modified":0,"renderable":0},{"_id":"source/_posts/docker-101-mod2/docker-run-new.gif","slug":"docker-run-new.gif","post":"cjb8926jl000bpbmlb6textz6","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjb8926h70000pbml7eu444gi","category_id":"cjb8926hl0002pbmlfbglaw9m","_id":"cjb8926ho0005pbmlk15vkn3z"},{"post_id":"cjb8926jl000bpbmlb6textz6","category_id":"cjb8926hl0002pbmlfbglaw9m","_id":"cjb8926jx000gpbml4tvv8unr"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","category_id":"cjb8926hl0002pbmlfbglaw9m","_id":"cjb8926jy000ipbmlfr5kmphu"},{"post_id":"cjb8926jt000fpbmllm3z48xv","category_id":"cjb8926hl0002pbmlfbglaw9m","_id":"cjb8926kd000npbmld9irdv7x"},{"post_id":"cjb8926jt000fpbmllm3z48xv","category_id":"cjb8926jy000jpbml2p0pvx0g","_id":"cjb8926ke000qpbmlljn8wp2k"}],"PostTag":[{"post_id":"cjb8926h70000pbml7eu444gi","tag_id":"cjb8926hi0001pbmlf2f4wju9","_id":"cjb8926hq0007pbmlxjfbmnb0"},{"post_id":"cjb8926h70000pbml7eu444gi","tag_id":"cjb8926hm0003pbml3v5r8aks","_id":"cjb8926hq0008pbml4ftsiubr"},{"post_id":"cjb8926h70000pbml7eu444gi","tag_id":"cjb8926hn0004pbml8b0d96im","_id":"cjb8926hq0009pbmljuaubw8r"},{"post_id":"cjb8926h70000pbml7eu444gi","tag_id":"cjb8926hq0006pbml5kdzlwda","_id":"cjb8926hr000apbmlwn6ae1v9"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926hi0001pbmlf2f4wju9","_id":"cjb8926kd000mpbml22bcid21"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926hm0003pbml3v5r8aks","_id":"cjb8926kd000opbmlds063lrs"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926hn0004pbml8b0d96im","_id":"cjb8926ke000rpbmlusipl9xp"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926hq0006pbml5kdzlwda","_id":"cjb8926ki000spbmlh7pansu4"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926js000epbml9dfqyex8","_id":"cjb8926kj000upbmlc4gthyjw"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926jx000hpbmlrw1ka6eh","_id":"cjb8926kj000vpbmlhnumkqlt"},{"post_id":"cjb8926jl000bpbmlb6textz6","tag_id":"cjb8926jy000kpbml1dg0sdac","_id":"cjb8926kk000xpbml8luzau0l"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926hi0001pbmlf2f4wju9","_id":"cjb8926l00013pbmlzmqgmx8m"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926kc000lpbmlzqkm3ysi","_id":"cjb8926l00014pbmlj6csvwog"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926kd000ppbmlt3w5zzg7","_id":"cjb8926l20015pbml8u6beuwf"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926ki000tpbml1yap8yy6","_id":"cjb8926l20016pbml4wq4x8ey"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926kk000wpbmljh2e1et3","_id":"cjb8926l30017pbmlyc9x0oxx"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926js000epbml9dfqyex8","_id":"cjb8926l40018pbmlgrdcsy51"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926hm0003pbml3v5r8aks","_id":"cjb8926l40019pbmlkryiqph2"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926kp000zpbml0c1lxcqh","_id":"cjb8926l5001apbmlafg24p5y"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926ks0010pbmlsmpk577n","_id":"cjb8926l6001bpbml5w4ibnnf"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926kt0011pbmlyyx4g51v","_id":"cjb8926l7001cpbmltme77ymn"},{"post_id":"cjb8926jn000dpbml5l0x8ysv","tag_id":"cjb8926hq0006pbml5kdzlwda","_id":"cjb8926l7001dpbmlc7r4ytmy"},{"post_id":"cjb8926jt000fpbmllm3z48xv","tag_id":"cjb8926hi0001pbmlf2f4wju9","_id":"cjb8926l8001epbmllm81ma4j"},{"post_id":"cjb8926jt000fpbmllm3z48xv","tag_id":"cjb8926hq0006pbml5kdzlwda","_id":"cjb8926l9001fpbmluor4nabt"},{"post_id":"cjb8926jt000fpbmllm3z48xv","tag_id":"cjb8926kv0012pbmlsxoixb5y","_id":"cjb8926l9001gpbml8gk1a1ag"}],"Tag":[{"name":"docker","_id":"cjb8926hi0001pbmlf2f4wju9"},{"name":"docker-cli","_id":"cjb8926hm0003pbml3v5r8aks"},{"name":"docker images","_id":"cjb8926hn0004pbml8b0d96im"},{"name":"docker 101","_id":"cjb8926hq0006pbml5kdzlwda"},{"name":"dockerfile","_id":"cjb8926js000epbml9dfqyex8"},{"name":"storage","_id":"cjb8926jx000hpbmlrw1ka6eh"},{"name":"volume mount","_id":"cjb8926jy000kpbml1dg0sdac"},{"name":"sandbox","_id":"cjb8926kc000lpbmlzqkm3ysi"},{"name":"backdoor","_id":"cjb8926kd000ppbmlt3w5zzg7"},{"name":"container ide","_id":"cjb8926ki000tpbml1yap8yy6"},{"name":"docker-compose","_id":"cjb8926kk000wpbmljh2e1et3"},{"name":"cloud9","_id":"cjb8926kp000zpbml0c1lxcqh"},{"name":"NetScaler","_id":"cjb8926ks0010pbmlsmpk577n"},{"name":"cpx","_id":"cjb8926kt0011pbmlyyx4g51v"},{"name":"containers","_id":"cjb8926kv0012pbmlsxoixb5y"}]}}